---
catalog:
  - jishu
date: '2026-01-11 08:00:00'
type: Post
slug: ffefawfa
title: 面试 | 前端应用型
status: 已发布
urlname: 2e5e9dc9-c245-80bf-8456-e02626021e06
updated: '2026-01-11 15:13:00'
---

## 暗黑模式 CSS 方案


这个我一时半会竟然想不到 想到的最简单的CSS文件切换


**核心方案：CSS 变量 + 类名切换**


这是目前最主流、最推荐的方案。它将颜色主题与组件逻辑解耦，维护成本极低，切换性能也非常高（因为只是修改一个根元素的属性）。


**1. 定义颜色变量**


在 **`:root`**（代表文档根元素 **`<html>`**）中定义默认（亮色）主题的颜色。


```css
/* :root 中的变量是全局默认值（亮色主题） */
:root {
  --bg-color: #ffffff;
  --text-color: #333333;
  --card-bg-color: #f4f4f4;
  --border-color: #dddddd;
  --primary-color: #007bff;
}
```


**2. 定义暗黑主题的颜色**


使用一个属性选择器（如 **`[data-theme='dark']`**）来覆盖默认变量，定义暗黑主题的颜色。


```css
/* 当 html 标签有 data-theme="dark" 属性时，应用这些变量值 */
[data-theme='dark'] {
  --bg-color: #121212;
  --text-color: #e0e0e0;
  --card-bg-color: #1e1e1e;
  --border-color: #333333;
  --primary-color: #4dabf7;
}
```


**3. 在组件中使用变量**


在所有需要根据主题变化颜色的地方，使用 **`var()`** 函数来引用变量。


```css
body {
  background-color: var(--bg-color);
  color: var(--text-color);
  transition: background-color 0.3s ease, color 0.3s ease; /* 添加平滑过渡效果 */
}

.card {
  background-color: var(--card-bg-color);
  border: 1px solid var(--border-color);
}

.button-primary {
  background-color: var(--primary-color);
}
```


**4. JavaScript 切换逻辑**


编写一个简单的 JS 函数来切换 **`<html>`** 元素的 **`data-theme`** 属性。

- **CSS 硬件加速**：切换主题只是改变一个 HTML 属性，浏览器会高效地重新计算样式并触发重绘，这个过程非常快。
- **避免 JS 操作样式**：我们不需要用 JS 遍历所有元素并逐个修改 **`style`**，这避免了昂贵的 DOM 操作和大量的回流/重绘。
- **CSS 变量的优势**：CSS 变量的更新是“继承式”的，修改根部的变量，所有后代引用该变量的地方都会自动更新，效率极高。

## **性能优化100000条数据**


通常指在前端渲染一个包含10万个项目的列表或表格。直接渲染10万个 DOM 元素是绝对不可行的，会导致页面瞬间卡死。核心思想是：**永远不要渲染你看不见的东西**。

**核心策略：虚拟滚动**

1. **计算可见区域**：容器有一个固定的高度，滚动时，计算出当前滚动条位置对应的应该显示的数据项的起始索引（**`startIndex`**）和结束索引（**`endIndex`**）。
2. **动态渲染**：只渲染 **`startIndex`** 到 **`endIndex`** 之间的数据项。
3. **撑开容器**：为了保持滚动条的正确比例，容器内部会有一个总高度为 **`itemHeight * totalCount`** 的“占位元素”。可见的列表项通过 **`transform: translateY()`** 来定位到正确的位置。
4. **分页**
    - **原理**：最简单粗暴的方法。将数据分成多页，用户通过点击页码来加载不同页的数据。
    - **优点**：实现简单，服务器和前端压力都小。
    - **缺点**：用户体验不连贯，无法快速浏览所有数据。
5. **无限滚动**
    - **原理**：用户滚动到底部时，通过 AJAX 加载下一页的数据，并追加到现有列表中。
    - **优点**：用户体验流畅，符合现代 Web 习惯。
    - **缺点**：如果一直滚动，DOM 节点会越来越多，最终还是会变慢。**（因此，对于超大数据，无限滚动必须结合虚拟滚动）**。
6. **Web Worker**
    - **场景**：当对这10万条数据进行复杂计算时（如搜索、过滤、排序），会阻塞主线程，导致页面卡顿。
    - **解决方案**：将这些计算密集型任务放到 Web Worker 中执行。Worker 在后台线程中运行，计算完成后将结果通过 **`postMessage`** 发回主线程，主线程再进行渲染。这样 UI 就不会被阻塞。

## 项目中的图片懒加载怎么实现


**方法一：浏览器原生懒加载 (****`loading="lazy"`****) - 推荐首选**


经我的实验验证，确实有用，但是条件很宽松，离视口很远的话才会触发懒加载不是不在视口就懒加载，而且听说网络条件好也会直接加载。缺点不好控制细节行为。


**方法二：使用 JavaScript** **`IntersectionObserver`** **API - 最灵活、最推荐的自定义方案**


不要将真实的图片地址放在 **`src`** 中，而是放在一个自定义的 **`data-src`** 属性里。**`src`** 可以放一个占位图，或者留空。监听视口轮到图片就挂上。


**方法三：基于** **`scroll`** **事件监听 +** **`getBoundingClientRect()`** **- 传统方法**


## SVG的使用


Svg图片在矢量领域挺受欢迎的，但是我之前一直老是用img去加载而大部分Web其实都是原生载入Svg。也就是说审查元素的时候是原生有Svg嵌入的，但是我img src的话基本就是直接引入，无法控制内部的元素。


**1.作为 Vue 组件使用**


**创建一个 SVG 组件文件，例如** **`src/components/icons/MenuIcon.vue`**


```typescript
// src/components/icons/MenuIcon.vue
<template>
  <svg 
    :width="size" 
    :height="size" 
    viewBox="0 0 24 24" 
    fill="none" 
    xmlns="http://www.w3.org/2000/svg"
  >
    <path d="M3 12H21M3 6H21M3 18H21" :stroke="color" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>
</template>

<script setup>
// 定义 props，让组件更灵活
defineProps({
  size: {
    type: [Number, String],
    default: 24,
  },
  color: {
    type: String,
    default: 'currentColor',
  }
});
</script>
```


**use example**


```typescript
<template>
  <div>
    <!-- 使用组件，并传入 props -->
    <MenuIcon size="32" color="red" />
    <MenuIcon />
  </div>
</template>

<script setup>
import MenuIcon from '@/components/icons/MenuIcon.vue';
</script>
```


**2.插件模版式自动导入**


借助插件来自动完成这个过程。这里以 Vite 为例，使用 `vite-plugin-svg-icons`。



```typescript
<template>
  <div>
    <!-- 直接使用，name 是文件名 -->
    <SvgIcon name="menu" size="24" color="blue" />
    <SvgIcon name="user" />
  </div>
</template>

<script setup>
// 如果全局注册了 SvgIcon，这里就不需要导入了
import SvgIcon from '@/components/SvgIcon.vue';
</script>
```


## 大文件切片上传


问题：大文件一次性传输不太好 需要断点续传，秒传，不阻塞


要点：blob.slice/chunks[]/sparkMD5/webworker


流程：用input拿到文件，然后把文件在前端用blob的api去做二进制切分，切分后存入数组得到分片，对每个分片进行单独的上传，上传完之后后端进行合并返回最后的上传成功信息。进度（用切片上传进度）


```typescript
<input type="file" id="file_upload" />
 <button id="upload_btn">upload now</button>  
  
  const file_upload = document.querySelector("#file_upload");
    let chunksList = [];
    const chunkSize = 2 * 1024 * 1024;

    let createChunks = (file) => {
      let curSize = 0;
      while (curSize < file.size) {
        //slice 越界也不会报错，它只返回剩余的数据部分
        chunksList.push(file.slice(curSize, curSize + chunkSize));
        curSize += chunkSize;
      }
    };

    document
      .querySelector("#upload_btn")
      .addEventListener("click", async () => {
        const file = file_upload.files[0];
        const file_name = file.name;
        createChunks(file);
        //封装成一个对象包装一下
        const uploadList = chunksList.map((item, index) => {
          return {
            blob_file: item,
            chunk_index: index,
            chunk_name: `${file_name}-${index}`,
            fileName: file_name,
          };
        });
        //包装我的请求
        const requestList = uploadList.map(
          ({ blob_file, chunk_index, chunk_name, fileName }) => {
            const formdata = new FormData();
            formdata.append("blob_file", blob_file);
            formdata.append("chunk_index", chunk_index);
            formdata.append("chunk_name", chunk_name);
            formdata.append("file_name", fileName);
            return axios({
              method: "POST",
              url: "https://localhost:3000/chunk_upload",
              data: formdata,
            });
          }
        );
        await Promise.all(requestList);
      });
```


## 用户通过修改文件后缀的方式上传，如何限制上传


**第一层是基础检查**：


在 **`<input type="file">`** 标签上添加 **`accept`** 属性
**第二层JS验证**：


检查每个文件的 **`file.type`**（MIME 类型）是否在允许的列表中
**第三层高级点的JS验证**：


读取文件的“魔数”（文件头部的特定字节序列 二进制流）


**第四层**：


让后端去看 最安全


## 网络请求状态码


| 类别      | 核心含义  | 常见代表                              | 解决方案（开发者视角）                  |
| ------- | ----- | --------------------------------- | ---------------------------- |
| **2xx** | 成功    | `200`, `201`, `204`               | 正常处理响应数据                     |
| **3xx** | 重定向   | `301`, `302`, `304`               | 浏览器自动跳转，开发者需关注缓存策略           |
| **4xx** | 客户端错误 | `400`, `401`, `403`, `404`, `429` | **检查前端代码**：请求URL、参数、权限、Token |
| **5xx** | 服务器错误 | `500`, `502`, `503`, `504`        | **检查后端代码和服务器**：日志、配置、资源状态    |


一般来说是(1-5)xx


1:基本不用


2: **`200 OK`** (访问一个网页 API成功）**`201 Created`** **（**用于 **`POST`** 请求后服务器成功创建某东西**）****`204 No Content`** **（**用于 **`DELETE`** 请求 成功但没返回）。


3:**`301 Moved Permanently`** 告诉你Url变了 **`302 Found`** 请求的资源**临时**移动到了另一个 URL
**`304 Not Modified`** 请求的资源未修改直接本地缓存


4：**`400 Bad Request`** 请求本身有语法错误或无效参数，服务器无法理解。


**`401 Unauthorized`** 请求需要身份验证


**`403 Forbidden`** 客户端已经认证，但没有权限访问该资源


**`404 Not Found`** 服务器上找不到请求的资源 客户端Url不对


**`405 Method Not Allowed`** 请求方法不对


**`429 Too Many Requests`** 发送了太多请求


5:**`500 Internal Server Error`** 


**`502 Bad Gateway`** 网关比如nginx出错


**`503 Service Unavailable`** 过载维护


**`504 Gateway Timeout`**


## 用Axios需要二次封装什么


**1. 统一的配置管理**


使用 **`axios.create()`** 创建一个 Axios 实例


```typescript
// src/utils/request.js
import axios from 'axios';

const service = axios.create({
  baseURL: 'https://api.example.com', // API 的基础 URL
  timeout: 10000, // 请求超时时间
  headers: {
    'Content-Type': 'application/json;charset=UTF-8'
  }
});
```




**2. 请求拦截器**


**统一添加认证信息**: 最常见的场景就是为每个请求自动带上 **`Token`** 


**处理请求参数**


**显示加载状态**


```typescript
// src/utils/request.js (接上文)
import { getToken } from './auth'; // 假设有一个获取 token 的工具函数

service.interceptors.request.use(
  config => {
    // 在发送请求之前做些什么
    const token = getToken();
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`; // 携带 token
    }
    return config;
  },
  error => {
    // 对请求错误做些什么
    console.error('Request Error:', error);
    return Promise.reject(error);
  }
);
```


**3. 响应拦截器**


**统一处理 HTTP 状态码**: 根据 HTTP 状态码（如 200, 401, 403, 500）进行统一判断。例如，遇到 401 (未授权) 时，可能意味着 Token 过期，此时可以跳转到登录页并清除本地 Token。


 **统一处理后端返回的数据结构**: 很多后端 API 会采用统一的数据格式，如 **`{ code: 0, data: {...}, message: 'success' }`**。在拦截器里，我们可以判断 **`code`**，如果成功，则只返回 **`response.data.data`**，这样业务代码中就不需要每次都解包了。如果失败，则统一处理错误提示。


**隐藏加载状态**: 在响应返回后，无论成功与否，都隐藏 Loading 动画。


```typescript
// src/utils/request.js (接上文)
import { ElMessage } from 'element-plus'; // 假设使用 Element Plus 的消息组件

service.interceptors.response.use(
  response => {
    // 2xx 范围内的状态码都会触发该函数。
    const res = response.data;

    // 假设后端约定 code 为 0 表示成功
    if (res.code !== 0) {
      ElMessage.error(res.message || 'Error');
      // 可以根据特定 code 处理特定业务，如 401 跳转登录页
      if (res.code === 401) {
        // to re-login
      }
      return Promise.reject(new Error(res.message || 'Error'));
    } else {
      // 只返回核心业务数据
      return res.data;
    }
  },
  error => {
    // 超出 2xx 范围的状态码都会触发该函数。
    console.error('Response Error:', error);
    ElMessage.error(error.message || 'Network Error');
    return Promise.reject(error);
  }
);
```


总结：


统一配置，通用逻辑和项目API集中。开发一处修改即可。

