---
catalog:
  - jishu
date: '2026-01-11 08:00:00'
type: Post
slug: ffefawfa
title: 面试 | 前端应用型
status: 已发布
urlname: 2e5e9dc9-c245-80bf-8456-e02626021e06
updated: '2026-01-20 22:30:00'
---

## 暗黑模式 CSS 方案


这个我一时半会竟然想不到 想到的最简单的CSS文件切换


**核心方案：CSS 变量 + 类名切换**


这是目前最主流、最推荐的方案。它将颜色主题与组件逻辑解耦，维护成本极低，切换性能也非常高（因为只是修改一个根元素的属性）。


**1. 定义颜色变量**


在 **`:root`**（代表文档根元素 **`<html>`**）中定义默认（亮色）主题的颜色。


```css
/* :root 中的变量是全局默认值（亮色主题） */
:root {
  --bg-color: #ffffff;
  --text-color: #333333;
  --card-bg-color: #f4f4f4;
  --border-color: #dddddd;
  --primary-color: #007bff;
}
```


**2. 定义暗黑主题的颜色**


使用一个属性选择器（如 **`[data-theme='dark']`**）来覆盖默认变量，定义暗黑主题的颜色。


```css
/* 当 html 标签有 data-theme="dark" 属性时，应用这些变量值 */
[data-theme='dark'] {
  --bg-color: #121212;
  --text-color: #e0e0e0;
  --card-bg-color: #1e1e1e;
  --border-color: #333333;
  --primary-color: #4dabf7;
}
```


**3. 在组件中使用变量**


在所有需要根据主题变化颜色的地方，使用 **`var()`** 函数来引用变量。


```css
body {
  background-color: var(--bg-color);
  color: var(--text-color);
  transition: background-color 0.3s ease, color 0.3s ease; /* 添加平滑过渡效果 */
}

.card {
  background-color: var(--card-bg-color);
  border: 1px solid var(--border-color);
}

.button-primary {
  background-color: var(--primary-color);
}
```


**4. JavaScript 切换逻辑**


编写一个简单的 JS 函数来切换 **`<html>`** 元素的 **`data-theme`** 属性。

- **CSS 硬件加速**：切换主题只是改变一个 HTML 属性，浏览器会高效地重新计算样式并触发重绘，这个过程非常快。
- **避免 JS 操作样式**：我们不需要用 JS 遍历所有元素并逐个修改 **`style`**，这避免了昂贵的 DOM 操作和大量的回流/重绘。
- **CSS 变量的优势**：CSS 变量的更新是“继承式”的，修改根部的变量，所有后代引用该变量的地方都会自动更新，效率极高。

## **性能优化100000条数据**


通常指在前端渲染一个包含10万个项目的列表或表格。直接渲染10万个 DOM 元素是绝对不可行的，会导致页面瞬间卡死。核心思想是：**永远不要渲染你看不见的东西**。




### **数据处理策略**

- 数据分片（分页展示）：将大型树结构分解成多个小块，按需加载各个部分。
- 虚拟列表：只渲染用户视口范围内的节点，减少DOM节点数量。
- 懒加载：初始只加载第一层或前几层数据，用户展开节点时再动态请求子节点数据

### 前端优化技术

- 数据扁平化：将树形结构转换为扁平结构，通过ID和parentID建立关系，便于管理和查询。
- Web Worker：将数据处理逻辑放在后台线程中执行，避免阻塞主线程。
- 缓存机制：使用浏览器存储（如IndexedDB、localStorage）缓存已加载的数据。

### 渲染优化


时间分片：使用requestAnimationFrame或setTimeout将渲染任务分割成小块，避免长时间阻塞主线程。


组件懒加载：结合React.lazy()和Suspense实现组件级别的懒加载。


节流与防抖：对滚动、展开等操作进行节流处理，减少重复渲染。


### 

1. **Web Worker**
    - **解决方案**：将这些计算密集型任务放到 Web Worker 中执行。Worker 在后台线程中运行，计算完成后将结果通过 **`postMessage`** 发回主线程，主线程再进行渲染。这样 UI 就不会被阻塞。

## 项目中的图片懒加载怎么实现


**方法一：浏览器原生懒加载 (****`loading="lazy"`****) - 推荐首选**


经我的实验验证，确实有用，但是条件很宽松，离视口很远的话才会触发懒加载不是不在视口就懒加载，而且听说网络条件好也会直接加载。缺点不好控制细节行为。


**方法二：使用 JavaScript** **`IntersectionObserver`** **API - 最灵活、最推荐的自定义方案**


不要将真实的图片地址放在 **`src`** 中，而是放在一个自定义的 **`data-src`** 属性里。**`src`** 可以放一个占位图，或者留空。监听视口轮到图片就挂上。


**方法三：基于** **`scroll`** **事件监听 +** **`getBoundingClientRect()`** **- 传统方法**


## SVG的使用


Svg图片在矢量领域挺受欢迎的，但是我之前一直老是用img去加载而大部分Web其实都是原生载入Svg。也就是说审查元素的时候是原生有Svg嵌入的，但是我img src的话基本就是直接引入，无法控制内部的元素。


**1.作为 Vue 组件使用**


**创建一个 SVG 组件文件，例如** **`src/components/icons/MenuIcon.vue`**


```typescript
// src/components/icons/MenuIcon.vue
<template>
  <svg 
    :width="size" 
    :height="size" 
    viewBox="0 0 24 24" 
    fill="none" 
    xmlns="http://www.w3.org/2000/svg"
  >
    <path d="M3 12H21M3 6H21M3 18H21" :stroke="color" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
  </svg>
</template>

<script setup>
// 定义 props，让组件更灵活
defineProps({
  size: {
    type: [Number, String],
    default: 24,
  },
  color: {
    type: String,
    default: 'currentColor',
  }
});
</script>
```


**use example**


```typescript
<template>
  <div>
    <!-- 使用组件，并传入 props -->
    <MenuIcon size="32" color="red" />
    <MenuIcon />
  </div>
</template>

<script setup>
import MenuIcon from '@/components/icons/MenuIcon.vue';
</script>
```


**2.插件模版式自动导入**


借助插件来自动完成这个过程。这里以 Vite 为例，使用 `vite-plugin-svg-icons`。



```typescript
<template>
  <div>
    <!-- 直接使用，name 是文件名 -->
    <SvgIcon name="menu" size="24" color="blue" />
    <SvgIcon name="user" />
  </div>
</template>

<script setup>
// 如果全局注册了 SvgIcon，这里就不需要导入了
import SvgIcon from '@/components/SvgIcon.vue';
</script>
```


## 大文件切片上传


问题：大文件一次性传输不太好 需要断点续传，秒传，不阻塞


要点：blob.slice/chunks[]/sparkMD5/webworker


流程：用input拿到文件，然后把文件在前端用blob的api去做二进制切分，切分后存入数组得到分片，对每个分片进行单独的上传，上传完之后后端进行合并返回最后的上传成功信息。进度（用切片上传进度）


```typescript
<input type="file" id="file_upload" />
 <button id="upload_btn">upload now</button>  
  
  const file_upload = document.querySelector("#file_upload");
    let chunksList = [];
    const chunkSize = 2 * 1024 * 1024;

    let createChunks = (file) => {
      let curSize = 0;
      while (curSize < file.size) {
        //slice 越界也不会报错，它只返回剩余的数据部分
        chunksList.push(file.slice(curSize, curSize + chunkSize));
        curSize += chunkSize;
      }
    };

    document
      .querySelector("#upload_btn")
      .addEventListener("click", async () => {
        const file = file_upload.files[0];
        const file_name = file.name;
        createChunks(file);
        //封装成一个对象包装一下
        const uploadList = chunksList.map((item, index) => {
          return {
            blob_file: item,
            chunk_index: index,
            chunk_name: `${file_name}-${index}`,
            fileName: file_name,
          };
        });
        //包装我的请求
        const requestList = uploadList.map(
          ({ blob_file, chunk_index, chunk_name, fileName }) => {
            const formdata = new FormData();
            formdata.append("blob_file", blob_file);
            formdata.append("chunk_index", chunk_index);
            formdata.append("chunk_name", chunk_name);
            formdata.append("file_name", fileName);
            return axios({
              method: "POST",
              url: "https://localhost:3000/chunk_upload",
              data: formdata,
            });
          }
        );
        await Promise.all(requestList);
      });
```


## 用户通过修改文件后缀的方式上传，如何限制上传


**第一层是基础检查**：


在 **`<input type="file">`** 标签上添加 **`accept`** 属性
**第二层JS验证**：


检查每个文件的 **`file.type`**（MIME 类型）是否在允许的列表中
**第三层高级点的JS验证**：


读取文件的“魔数”（文件头部的特定字节序列 二进制流）


**第四层**：


让后端去看 最安全


## 网络请求状态码


| 类别      | 核心含义  | 常见代表                              | 解决方案（开发者视角）                  |
| ------- | ----- | --------------------------------- | ---------------------------- |
| **2xx** | 成功    | `200`, `201`, `204`               | 正常处理响应数据                     |
| **3xx** | 重定向   | `301`, `302`, `304`               | 浏览器自动跳转，开发者需关注缓存策略           |
| **4xx** | 客户端错误 | `400`, `401`, `403`, `404`, `429` | **检查前端代码**：请求URL、参数、权限、Token |
| **5xx** | 服务器错误 | `500`, `502`, `503`, `504`        | **检查后端代码和服务器**：日志、配置、资源状态    |


一般来说是(1-5)xx


1:基本不用


2: **`200 OK`** (访问一个网页 API成功）**`201 Created`** **（**用于 **`POST`** 请求后服务器成功创建某东西**）****`204 No Content`** **（**用于 **`DELETE`** 请求 成功但没返回）。


3:**`301 Moved Permanently`** 告诉你Url变了 **`302 Found`** 请求的资源**临时**移动到了另一个 URL
**`304 Not Modified`** 请求的资源未修改直接本地缓存


4：**`400 Bad Request`** 请求本身有语法错误或无效参数，服务器无法理解。


**`401 Unauthorized`** 请求需要身份验证


**`403 Forbidden`** 客户端已经认证，但没有权限访问该资源


**`404 Not Found`** 服务器上找不到请求的资源 客户端Url不对


**`405 Method Not Allowed`** 请求方法不对


**`429 Too Many Requests`** 发送了太多请求


5:**`500 Internal Server Error`** 


**`502 Bad Gateway`** 网关比如nginx出错


**`503 Service Unavailable`** 过载维护


**`504 Gateway Timeout`**


## 用Axios需要二次封装什么


**1. 统一的配置管理**


使用 **`axios.create()`** 创建一个 Axios 实例


```typescript
// src/utils/request.js
import axios from 'axios';

const service = axios.create({
  baseURL: 'https://api.example.com', // API 的基础 URL
  timeout: 10000, // 请求超时时间
  headers: {
    'Content-Type': 'application/json;charset=UTF-8'
  }
});
```




**2. 请求拦截器**


**统一添加认证信息**: 最常见的场景就是为每个请求自动带上 **`Token`** 


**处理请求参数**


**显示加载状态**


```typescript
// src/utils/request.js (接上文)
import { getToken } from './auth'; // 假设有一个获取 token 的工具函数

service.interceptors.request.use(
  config => {
    // 在发送请求之前做些什么
    const token = getToken();
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`; // 携带 token
    }
    return config;
  },
  error => {
    // 对请求错误做些什么
    console.error('Request Error:', error);
    return Promise.reject(error);
  }
);
```


**3. 响应拦截器**


**统一处理 HTTP 状态码**: 根据 HTTP 状态码（如 200, 401, 403, 500）进行统一判断。例如，遇到 401 (未授权) 时，可能意味着 Token 过期，此时可以跳转到登录页并清除本地 Token。


 **统一处理后端返回的数据结构**: 很多后端 API 会采用统一的数据格式，如 **`{ code: 0, data: {...}, message: 'success' }`**。在拦截器里，我们可以判断 **`code`**，如果成功，则只返回 **`response.data.data`**，这样业务代码中就不需要每次都解包了。如果失败，则统一处理错误提示。


**隐藏加载状态**: 在响应返回后，无论成功与否，都隐藏 Loading 动画。


```typescript
// src/utils/request.js (接上文)
import { ElMessage } from 'element-plus'; // 假设使用 Element Plus 的消息组件

service.interceptors.response.use(
  response => {
    // 2xx 范围内的状态码都会触发该函数。
    const res = response.data;

    // 假设后端约定 code 为 0 表示成功
    if (res.code !== 0) {
      ElMessage.error(res.message || 'Error');
      // 可以根据特定 code 处理特定业务，如 401 跳转登录页
      if (res.code === 401) {
        // to re-login
      }
      return Promise.reject(new Error(res.message || 'Error'));
    } else {
      // 只返回核心业务数据
      return res.data;
    }
  },
  error => {
    // 超出 2xx 范围的状态码都会触发该函数。
    console.error('Response Error:', error);
    ElMessage.error(error.message || 'Network Error');
    return Promise.reject(error);
  }
);
```


总结：


统一配置，通用逻辑和项目API集中。开发一处修改即可。


## **Broadcast Channel API** 


用法：同域名跨tab、iframe、worker等通信


```typescript
//创建和连接频道
// 创建或连接到名为"example-channel"的广播频道
const channel = new BroadcastChannel('example-channel');

// 另一个tab上监听频道上的消息
channel.addEventListener('message', (event) => {
  console.log('收到消息:', event.data);
});

// 另一个tab上发送消息到所有监听该频道的接收者
channel.postMessage({
  type: 'UPDATE',
  payload: { message: '这是一条广播消息' },
  timestamp: Date.now()
});

//此时tab1接收到信息
```


## API


 js获取属性（对象方法）


| 方式           | 示例                               | 说明        |
| ------------ | -------------------------------- | --------- |
| 点访问          | `obj.name`                       | 最常用       |
| 方括号          | `obj["name"]`                    | 动态属性名     |
| 获取 key       | `Object.keys()`                  | 可枚举属性     |
| 获取 value     | `Object.values()`                | 可枚举值      |
| 获取 entries   | `Object.entries()`               | key-value |
| 获取所有属性名      | `Object.getOwnPropertyNames()`   | 包含不可枚举    |
| 获取 Symbol 属性 | `Object.getOwnPropertySymbols()` | 符号属性      |
| 解构           | `const {a} = obj`                | 语法糖       |
| 可选链          | `obj?.a?.b`                      | 防报错       |
| Reflect      | `Reflect.get(obj, key)`          | 更规范的 API  |
| Proxy 拦截     | `new Proxy(obj,{get(){}})`       | 底层机制      |


扩展运算符用法



✅ 1. **对象扩展（Object Spread）**


**① 浅拷贝对象**



```typescript
let a = { x: 1, y: 2 };
let b = { ...a };

console.log(b); // { x: 1, y: 2 }
console.log(b === a); // false
```


**② 覆盖字段**


```typescript
let a = { x: 1, y: 2 };
let b = { ...a, y: 999 };

console.log(b); // { x: 1, y: 999 }
```


**③ 合并多个对象**


```typescript
const a = { x: 1 };
const b = { y: 2 };
const c = { z: 3 };

const result = { ...a, ...b, ...c };
```


**④ 删除字段（搭配解构）**


```typescript
const { password, ...userInfo } = user;
```



✅ 2. **数组扩展（Array Spread）**


**① 浅拷贝数组**


```typescript
const a = [1, 2, 3];
const b = [...a];
```


**② 合并数组**


```typescript
const c = [...a, ...b];
```


**③ 在中间插入**


```typescript
const arr = [1, ...[3, 4], 5];
```



✅ 3. **函数参数展开**


**① 把数组展开成参数**



```typescript
function sum(a, b, c) {
  return a + b + c;
}

const arr = [1, 2, 3];
sum(...arr); // 6
```


**② 替代 apply**


```typescript
Math.max(...nums);
```



✅ 4. **剩余参数（Rest Parameters）**


```typescript
function fn(a, ...rest) {
  console.log(a);     // 第一个参数
  console.log(rest);  // 剩下的参数组成数组
}
```


| 用法     | 示例               | 意义         |
| ------ | ---------------- | ---------- |
| 对象拷贝   | `{ ...a }`       | 浅拷贝        |
| 对象合并   | `{ ...a, ...b }` | 合并并覆盖      |
| 数组拷贝   | `[ ...arr ]`     | 浅拷贝        |
| 数组合并   | `[ ...a, ...b ]` | 相当于 concat |
| 函数参数展开 | `fn(...args)`    | 相当于 apply  |
| 剩余参数   | `(...args)`      | 收集剩余参数     |


一些内置对象方法


### Array



✅ **A. 遍历类（最常考）**


| 方法        | 作用            | 是否返回新数组 | 是否可中断  |
| --------- | ------------- | ------- | ------ |
| `forEach` | 遍历但不返回        | ❌       | ❌      |
| `map`     | 遍历并返回新数组      | ✔       | ❌      |
| `filter`  | 筛选返回新数组       | ✔       | ❌      |
| `reduce`  | 累积（求和、扁平化、计数） | ✔（自定义）  | ❌      |
| `some`    | 有一个满足就 true   | 返回 bool | ✔（可中断） |
| `every`   | 全部满足才 true    | 返回 bool | ✔      |



✅ **B. 查找类**


| 方法          | 作用                  |
| ----------- | ------------------- |
| `find`      | 返回 _第一个_ 满足条件的元素    |
| `findIndex` | 返回满足条件的 _下标_        |
| `indexOf`   | 查基本类型的位置            |
| `includes`  | 是否存在（比 indexOf 更常用） |



✅ **C. 修改原数组的方法（副作用）**


| 方法        | 作用             |
| --------- | -------------- |
| `push`    | 末尾添加           |
| `pop`     | 末尾删除           |
| `shift`   | 开头删除           |
| `unshift` | 开头添加           |
| `splice`  | （万能增删改）**最常考** |
| `sort`    | 排序（常考比较函数写法）   |
| `reverse` | 反转数组           |



✅ **D. 不修改原数组的方法（生成新数组）**


| 方法       | 作用                   |
| -------- | -------------------- |
| `slice`  | 截取                   |
| `concat` | 合并                   |
| `join`   | 转字符串                 |
| `flat`   | 扁平化（如 `[1,[2,[3]]]`） |


### Object


| 方法                   | 说明            |
| -------------------- | ------------- |
| `Object.keys`        | 取 key 数组      |
| `Object.values`      | 取 value 数组    |
| `Object.entries`     | 转 map-like 数组 |
| `Object.fromEntries` | 逆操作           |
| `Object.assign`      | 拷贝/合并         |
| `Object.freeze`      | 冻结            |
| `Object.seal`        | 密封            |


数组splice/slice


| 特性       | `splice()`                    | `slice()`      |
| -------- | ----------------------------- | -------------- |
| **功能**   | 增删改数组元素                       | 提取数组片段         |
| **原数组**  | 直接修改                          | 不修改            |
| **返回值**  | 被删除的元素组成的新数组                  | 提取的元素组成的新数组    |
| **参数**   | `(start, deleteCount, items)` | `(start, end)` |
| **使用场景** | 动态修改数组内容                      | 安全获取子数组        |


**DOM 操作 API**


**1. 获取元素**


| API                                          | 描述                                                          | 示例                                                                        |
| -------------------------------------------- | ----------------------------------------------------------- | ------------------------------------------------------------------------- |
| **通过 ID/Class/Tag**                          |                                                             |                                                                           |
| `document.getElementById(id)`                | 获取具有指定 ID 的**单个**元素。                                        | `const main = document.getElementById('main');`                           |
| `document.getElementsByClassName(className)` | 获取包含指定类名的所有元素，返回 `HTMLCollection`。                          | `const warnings = document.getElementsByClassName('warning');`            |
| `document.getElementsByTagName(tagName)`     | 获取具有指定标签名的所有元素，返回 `HTMLCollection`。                         | `const allImages = document.getElementsByTagName('img');`                 |
| **通过 CSS 选择器 (推荐)**                          |                                                             |                                                                           |
| `document.querySelector(selector)`           | 获取匹配 CSS 选择器的**第一个**元素。                                     | `const submitBtn = document.querySelector('form button[type="submit"]');` |
| `document.querySelectorAll(selector)`        | 获取匹配 CSS 选择器的**所有**元素，返回 `NodeList`。                        | `const listItems = document.querySelectorAll('ul li > a');`               |
| **获取特定集合**                                   |                                                             |                                                                           |
| `document.forms`                             | 返回文档中所有 `<form>` 元素的 `HTMLCollection`。                      | `const loginForm = document.forms['login'];`                              |
| `document.images`                            | 返回文档中所有 `<img>` 元素的 `HTMLCollection`。                       | `const firstImg = document.images[0];`                                    |
| `document.links`                             | 返回文档中所有具有 `href` 属性的 `<area>` 和 `<a>` 元素的 `HTMLCollection`。 | `const firstLink = document.links[0];`                                    |
| **直接访问文档根节点**                                |                                                             |                                                                           |
| `document.documentElement`                   | 获取 `<html>` 元素。                                             | `const htmlEl = document.documentElement;`                                |
| `document.head`                              | 获取 `<head>` 元素。                                             | `const headEl = document.head;`                                           |
| `document.body`                              | 获取 `<body>` 元素。                                             | `const bodyEl = document.body;`                                           |


**2. 修改元素内容**


| API                   | 描述                                               | 示例                                                |
| --------------------- | ------------------------------------------------ | ------------------------------------------------- |
| `element.innerHTML`   | 获取或设置元素的 HTML 内容。**（强大但有 XSS 风险）**               | `div.innerHTML = '<p>新内容</p>';`                   |
| `element.outerHTML`   | 获取或设置包含元素自身的 HTML。                               | `p.outerHTML = '<div>' + p.innerHTML + '</div>';` |
| `element.textContent` | 获取或设置元素及其后代的**所有**文本内容（纯文本，忽略标签）。                | `p.textContent = '这段文本不会被解析为HTML';`               |
| `element.innerText`   | 获取或设置元素“渲染后”的可见文本内容（受 CSS 影响，如 `display: none`）。 | `p.innerText = '这是可见的文本';`                        |


**3. 修改元素属性**


| API                                 | 描述                           | 示例                                                    |
| ----------------------------------- | ---------------------------- | ----------------------------------------------------- |
| **标准属性**                            |                              |                                                       |
| `element.id` / `element.className`  | 直接获取或设置 `id` 和 `class` 属性。   | `div.className = 'container active';`                 |
| `element.src` / `element.href`      | 直接获取或设置 `src` 和 `href` 等属性。  | `img.src = 'new-image.jpg';`                          |
| **通用属性方法**                          |                              |                                                       |
| `element.getAttribute(attr)`        | 获取属性值（包括自定义属性）。              | `const dataId = div.getAttribute('data-id');`         |
| `element.setAttribute(attr, value)` | 设置属性值。                       | `div.setAttribute('role', 'button');`                 |
| `element.hasAttribute(attr)`        | 检查是否拥有某属性。                   | `if (input.hasAttribute('required')) { ... }`         |
| `element.removeAttribute(attr)`     | 移除属性。                        | `input.removeAttribute('disabled');`                  |
| `element.attributes`                | 返回元素所有属性的 `NamedNodeMap` 集合。 | `const attrs = element.attributes;`                   |
| **`data-*`** **自定义数据属性**            |                              |                                                       |
| `element.dataset`                   | 一个对象，用于访问所有 `data-*` 属性。     | `div.dataset.userId = '123';`<br>`// 对应 data-user-id` |


**4. 修改元素样式**


| API                                             | 描述                         | 示例                                                                                   |
| ----------------------------------------------- | -------------------------- | ------------------------------------------------------------------------------------ |
| **操作内联样式**                                      |                            |                                                                                      |
| `element.style.property`                        | 设置单个 CSS 样式，属性名用驼峰命名法。     | `div.style.backgroundColor = '#f0f0f0';`                                             |
| `element.style.cssText`                         | 一次性设置多个内联样式字符串。            | `div.style.cssText = 'color: red; font-size: 20px;';`                                |
| **操作 Class (推荐)**                               |                            |                                                                                      |
| `element.classList.add(class1, ...)`            | 添加一个或多个类。                  | `div.classList.add('show', 'animated');`                                             |
| `element.classList.remove(class1, ...)`         | 移除一个或多个类。                  | `div.classList.remove('hidden');`                                                    |
| `element.classList.toggle(className)`           | 切换类（有则删，无则加）。              | `button.classList.toggle('active');`                                                 |
| `element.classList.contains(className)`         | 检查是否包含某类。                  | `if (div.classList.contains('error')) { ... }`                                       |
| **获取计算后的样式**                                    |                            |                                                                                      |
| `window.getComputedStyle(element, [pseudoElt])` | 获取元素最终应用的、所有 CSS 属性值的只读对象。 | `const style = getComputedStyle(myDiv);`<br>`const bgColor = style.backgroundColor;` |


**5. 创建、插入和删除节点**


| API                                         | 描述                               | 示例                                                |
| ------------------------------------------- | -------------------------------- | ------------------------------------------------- |
| **创建节点**                                    |                                  |                                                   |
| `document.createElement(tagName)`           | 创建一个元素节点。                        | `const newLi = document.createElement('li');`     |
| `document.createTextNode(text)`             | 创建一个文本节点。                        | `const text = document.createTextNode('Item 4');` |
| `document.createDocumentFragment()`         | 创建一个轻量级的文档片段，用于批量操作，可提升性能。       | `const frag = document.createDocumentFragment();` |
| **插入节点**                                    |                                  |                                                   |
| `parentNode.appendChild(childNode)`         | 将节点添加到父节点的子节点列表的**末尾**。          | `ul.appendChild(newLi);`                          |
| `parentNode.insertBefore(newNode, refNode)` | 将节点插入到参考节点之前。                    | `ul.insertBefore(newLi, ul.firstChild);`          |
| `element.prepend(...nodes)`                 | 将节点或字符串插入到元素内部的**开头**。           | `div.prepend(newHeading, 'Some text');`           |
| `element.append(...nodes)`                  | 将节点或字符串插入到元素内部的**末尾**。           | `div.append(newParagraph);`                       |
| `element.before(...nodes)`                  | 将节点或字符串插入到元素**之前**。              | `oldDiv.before(newDiv);`                          |
| `element.after(...nodes)`                   | 将节点或字符串插入到元素**之后**。              | `oldDiv.after(newDiv);`                           |
| `element.replaceWith(...nodes)`             | 用新节点替换当前元素。                      | `oldSpan.replaceWith(newSpan);`                   |
| **删除与克隆**                                   |                                  |                                                   |
| `node.remove()`                             | 从 DOM 中删除节点自身。                   | `myDiv.remove();`                                 |
| `parentNode.removeChild(childNode)`         | 从父节点中删除子节点。                      | `ul.removeChild(ul.lastChild);`                   |
| `node.cloneNode(deep)`                      | 克隆节点。`deep` 为 `true` 时，克隆所有后代节点。 | `const clonedDiv = originalDiv.cloneNode(true);`  |


**6. 节点关系与遍历**


| API                                                       | 描述                                         | 示例                                                   |
| --------------------------------------------------------- | ------------------------------------------ | ---------------------------------------------------- |
| **父子关系**                                                  |                                            |                                                      |
| `node.parentNode`                                         | 获取父节点。                                     | `const parent = childNode.parentNode;`               |
| `node.parentElement`                                      | 获取父元素节点。                                   | `const parentEl = childNode.parentElement;`          |
| `node.childNodes`                                         | 获取所有子节点（包括文本、注释等），返回 `NodeList`。           | `const kids = parentDiv.childNodes;`                 |
| `node.children`                                           | 获取所有子**元素**节点，返回 `HTMLCollection`。         | `const kidEls = parentDiv.children;`                 |
| `node.firstChild` / `node.lastChild`                      | 获取第一个/最后一个子节点（可能不是元素）。                     | `const first = parentDiv.firstChild;`                |
| `node.firstElementChild` / `node.lastElementChild`        | 获取第一个/最后一个子**元素**节点。                       | `const firstEl = parentDiv.firstElementChild;`       |
| **兄弟关系**                                                  |                                            |                                                      |
| `node.previousSibling` / `node.nextSibling`               | 获取前一个/后一个兄弟节点（可能不是元素）。                     | `const prev = currentNode.nextSibling;`              |
| `node.previousElementSibling` / `node.nextElementSibling` | 获取前一个/后一个兄弟**元素**节点。                       | `const prevEl = currentNode.previousElementSibling;` |
| **节点信息**                                                  |                                            |                                                      |
| `node.nodeType`                                           | 获取节点类型（1: Element, 3: Text, 8: Comment 等）。 | `if (node.nodeType === 1) { /* it's an element */ }` |
| `node.nodeName` / `node.tagName`                          | 获取节点名称（大写，如 'DIV'）。`tagName` 只对元素有效。       | `console.log(element.tagName); // "DIV"`             |
| `node.contains(otherNode)`                                | 检查 `otherNode` 是否是 `node` 的后代节点。           | `if (document.body.contains(myDiv)) { ... }`         |


**7. 元素尺寸与位置**


| API                                    | 描述                                                                                                     | 示例                                                                                    |
| -------------------------------------- | ------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------- |
| **元素尺寸**                               |                                                                                                        |                                                                                       |
| `element.offsetWidth` / `offsetHeight` | 元素的**布局宽高**，包括 `width`/`height`、`padding`、`border` 和滚动条（整数）。                                           | `const width = div.offsetWidth;`                                                      |
| `element.clientWidth` / `clientHeight` | 元素的**可视宽高**，包括 `width`/`height` 和 `padding`，不包括 `border` 和滚动条（整数）。                                     | `const height = div.clientHeight;`                                                    |
| `element.scrollWidth` / `scrollHeight` | 元素的**总内容宽高**，包括因溢出而不可见的部分（整数）。                                                                         | `const totalHeight = div.scrollHeight;`                                               |
| **元素位置**                               |                                                                                                        |                                                                                       |
| `element.offsetLeft` / `offsetTop`     | 相对于 `offsetParent` 的左/上边距。                                                                             | `const top = div.offsetTop;`                                                          |
| `element.clientLeft` / `clientTop`     | 元素左边框/上边框的宽度（通常为 0，除非有滚动条）。                                                                            | `const borderLeft = div.clientLeft;`                                                  |
| `element.scrollLeft` / `scrollTop`     | 元素水平/垂直滚动条滚动的距离（可读写）。                                                                                  | `div.scrollTop = 100; // 滚动到100px的位置`                                                 |
| `element.getBoundingClientRect()`      | 返回元素的大小及其相对于视口的位置，返回一个 `DOMRect` 对象（包含 `x`, `y`, `width`, `height`, `left`, `top`, `right`, `bottom`）。 | `const rect = button.getBoundingClientRect();`<br>`console.log(rect.top, rect.left);` |


**8. 事件处理**


| API                                                 | 描述                                                                                                            | 示例                                                                                           |
| --------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- |
| **监听与移除**                                           |                                                                                                               |                                                                                              |
| `element.addEventListener(event, handler, options)` | 添加事件监听器。**（推荐）**                                                                                              | `btn.addEventListener('click', handleClick, { capture: false, once: true, passive: true });` |
| `element.removeEventListener(event, handler)`       | 移除事件监听器。                                                                                                      | `btn.removeEventListener('click', handleClick);`                                             |
| **事件对象**                                            |                                                                                                               |                                                                                              |
| `event.target`                                      | 触发事件的**最具体**元素（事件冒泡的起点）。                                                                                      | `function(e) { console.log(e.target); }`                                                     |
| `event.currentTarget`                               | 绑定事件监听器的元素。                                                                                                   | `function(e) { console.log(e.currentTarget); }`                                              |
| `event.preventDefault()`                            | 阻止事件的默认行为（如链接跳转、表单提交）。                                                                                        | `form.addEventListener('submit', (e) => e.preventDefault());`                                |
| `event.stopPropagation()`                           | 阻止事件在 DOM 树中继续冒泡或捕获。                                                                                          | `child.addEventListener('click', (e) => e.stopPropagation());`                               |
| `event.stopImmediatePropagation()`                  | 阻止同一元素上的其他同类事件监听器被触发。                                                                                         | `btn1.addEventListener('click', (e) => e.stopImmediatePropagation());`                       |
| **常见事件类型**                                          |                                                                                                               |                                                                                              |
| 鼠标事件                                                | `click`, `dblclick`, `mousedown`, `mouseup`, `mouseover`, `mouseout`, `mouseenter`, `mouseleave`, `mousemove` |                                                                                              |
| 键盘事件                                                | `keydown`, `keyup`, `keypress`                                                                                |                                                                                              |
| 表单事件                                                | `submit`, `change`, `input`, `focus`, `blur`                                                                  |                                                                                              |
| 窗口事件                                                | `load`, `DOMContentLoaded`, `resize`, `scroll`                                                                |                                                                                              |

