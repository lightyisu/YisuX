---
catalog:
  - jishu
date: '2025-11-08 08:00:00'
type: Post
slug: jishusss
title: 「前端路线」面试收集
status: 已发布
urlname: 2a5e9dc9-c245-8040-af90-c77fe0c7c682
updated: '2025-12-11 19:59:00'
---

收集一点面试题。说实话我是感觉没啥用的大部分记住了以后就会忘记除非用的时候再想起，也是没办法。


大致的面试方向让GPT列了一下，用于对照有没有缺的：


# 路线表：


## **第一部分：前端基础（The Core Fundamentals）**


### **1. JavaScript (重中之重)**

- **核心概念：**
	- **数据类型**：基本类型 vs 引用类型，**`null`** vs **`undefined`**，**`Symbol`** 和 **`BigInt`**。
	- **类型转换**：隐式转换规则（特别是 **`==`** 和 **`+`**），显式转换方法。
	- **作用域 (Scope) 与作用域链**：全局作用域、函数作用域、块级作用域 (**`let`**/**`const`**)。
	- **闭包 (Closure)**：是什么、为什么、应用场景（防抖、节流、模块化）、可能导致的内存泄漏。
	- **`this`** **指向**：不同场景下（全局、函数、对象方法、箭头函数、**`call/apply/bind`**）的 **`this`** 指向问题。
	- **原型 (Prototype) 与原型链**：**`__proto__`**、**`prototype`**、**`constructor`** 的关系，继承的实现方式。
	- **执行上下文 (Execution Context) 与调用栈 (Call Stack)**。
- **异步编程：**
	- **事件循环 (Event Loop)**：宏任务 (Macrotask) 与微任务 (Microtask) 的区别和执行顺序（非常高频的考点）。
	- **Promise**：三种状态、**`then`**/**`catch`**/**`finally`**，**`Promise.all`**/**`race`**/**`any`** 的用法和区别。
	- **`async/await`**：语法糖的本质，如何处理错误（**`try...catch`**）。
- **ES6+ 新特性：**
	- **`let`** / **`const`** vs **`var`** 的区别。
	- 箭头函数及其 **`this`**。
	- 解构赋值、模板字符串、默认参数。
	- **`Map`** / **`Set`** vs **`Object`** / **`Array`**。
	- 模块化 (**`import`**/**`export`**)。
	- **`Class`** 语法糖。
- **手写代码题（高频）：**
	- 防抖 (Debounce) 和节流 (Throttle)。
	- 深拷贝 (Deep Clone)。
	- 实现 **`call`** / **`apply`** / **`bind`**。
	- 实现一个 **`Promise`** 或 **`Promise.all`**。
	- 数组扁平化、去重。
	- 实现一个事件发布/订阅模型 (Event Emitter)。

	### **2. CSS (Cascading Style Sheets)**

	- **核心概念：**
		- **盒子模型 (Box Model)**：标准盒模型 vs IE 盒模型 (**`box-sizing`**)。
		- **选择器与优先级**：**`!important > 内联 > ID > 类/属性/伪类 > 标签 > 通配符`**。
		- **BFC (块级格式化上下文)**：是什么、触发条件、应用场景（清除浮动、防止 margin 塌陷）。
		- **层叠上下文 (Stacking Context)**：**`z-index`** 的工作原理。
	- **布局 (Layout)：**
		- **Flexbox 布局**：主轴、交叉轴、**`flex-direction`**, **`justify-content`**, **`align-items`**, **`flex`** 属性。
		- **Grid 布局**：二维布局，**`grid-template-columns/rows`**, **`grid-gap`**, **`grid-area`**。
		- **定位 (Positioning)**：**`static`**, **`relative`**, **`absolute`**, **`fixed`**, **`sticky`** 的区别和用途。
		- **浮动 (Float)**：以及如何清除浮动。
	- **进阶与工程化：**
		- **CSS 动画**：**`transition`** 和 **`animation`** 的区别。
		- **预处理器**：Sass/Less/Stylus（变量、Mixin、嵌套等）。
		- **CSS Modules / CSS-in-JS**：解决 CSS 全局污染和作用域问题。
		- **响应式设计**：媒体查询 (**`@media`**)。

	### **3. HTML (HyperText Markup Language)**

	- **语义化标签**：**`header`**, **`footer`**, **`nav`**, **`section`**, **`article`**, **`aside`** 的使用场景，好处是什么（SEO、可访问性）。
	- **HTML5 新特性**：**`canvas`**, **`video`**, **`audio`**, 新的表单类型。
	- **DOCTYPE 的作用**：触发标准模式。
	- **可访问性 (Accessibility, a11y)**：**`alt`** 属性，**`aria-*`** 属性的角色。
	- **SEO (搜索引擎优化)**：**`title`**, **`meta`** 标签的优化。

## **第二部分：框架与库 (Frameworks & Libraries)**


通常要求至少精通一个主流框架。

- **React / Vue (选择一个深入)**
	- **核心思想**：声明式 UI、组件化、数据驱动视图。
	- **Virtual DOM**：是什么，为什么需要它，Diff 算法（非常重要，需要理解其 key 的作用和 diff 过程）。
	- **组件生命周期**：创建、更新、销毁各个阶段的钩子函数。
	- **组件通信**：父子、子父、兄弟、跨级通信的各种方式。
	- **状态管理**：
		- **React**: **`useState`**, **`useReducer`**, **`Context API`**，以及 Redux / Zustand / MobX 的原理和使用。
		- **Vue**: **`props`**, **`$emit`**, EventBus, Vuex / Pinia 的原理和使用。
	- **React Hooks vs. Vue Composition API**：它们的优势和解决了什么问题。
	- **原理深挖**：
		- **React**: Fiber 架构、Scheduler、合成事件。
		- **Vue**: 响应式原理（**`Object.defineProperty`** vs **`Proxy`**）。

## **第三部分：工程化与工具链 (Engineering & Tooling)**


这部分体现你的工程能力和开发效率。

- **构建工具**：
	- **Webpack**：核心概念（Entry, Output, Loader, Plugin, Mode），工作流程，常见优化（代码分割、Tree Shaking、打包速度优化）。
	- **Vite**：与 Webpack 的区别，为什么快（ESM、esbuild）。
- **包管理器**：**`npm`** / **`yarn`** / **`pnpm`** 的区别，**`package.json`** 和 **`package-lock.json`** 的作用。
- **代码规范与质量**：ESLint (代码检查), Prettier (代码格式化), TypeScript (类型系统)。
- **Git 版本控制**：常用命令 (**`merge`** vs **`rebase`**, **`cherry-pick`**, **`reset`**)，分支管理策略 (Git Flow)。
- **前端测试**：单元测试 (Jest/Vitest), E2E 测试 (Cypress/Playwright)。

## **第四部分：浏览器与网络 (Browser & Network)**


这部分是高级和资深岗位的分水岭。

- **浏览器渲染原理**：
	- **关键渲染路径 (Critical Rendering Path)**：从输入 URL到页面展示的全过程（DNS 查询 -> TCP 握手 -> HTTP 请求 -> 解析 HTML -> 构建 DOM 树 -> 构建 CSSOM 树 -> 构建渲染树 -> 布局 -> 绘制）。
	- **重排 (Reflow/Layout) 与 重绘 (Repaint)**：是什么，区别，如何减少。
- **网络协议**：
	- **HTTP/HTTPS**：状态码 (200, 301, 304, 403, 404, 500 等)，请求方法 (GET/POST 区别)，Headers (Cache-Control, ETag, Cookie, Content-Type 等)。
	- **HTTP 缓存**：强缓存和协商缓存的机制和区别。
	- **跨域 (CORS)**：原因和解决方案（JSONP, CORS, Nginx 反向代理）。
	- **TCP/IP**：三次握手、四次挥手。
- **浏览器存储**：**`Cookie`** / **`localStorage`** / **`sessionStorage`** / **`IndexedDB`** 的区别和应用场景。
- **安全性**：XSS (跨站脚本攻击), CSRF (跨站请求伪造) 的原理和防范。

## **第五部分：性能优化 (Performance Optimization)**


衡量一个前端工程师能力的重要标准。

- **加载性能优化**：
	- **资源压缩与合并**：JS/CSS/HTML 压缩，图片压缩（WebP 格式）。
	- **代码分割 (Code Splitting)** 和 **按需加载 (Lazy Loading)**。
	- **Tree Shaking**：移除无用代码。
	- **使用 CDN**。
- **渲染性能优化**：
	- 减少重排和重绘。
	- 使用 **`requestAnimationFrame`** 处理动画。
	- 长列表的虚拟滚动 (Virtual Scrolling)。
- **性能监控与分析工具**：
	- Chrome DevTools (Lighthouse, Performance, Network 面板)。
	- **`window.performance`** API。

## **第六部分：算法、数据结构与设计模式**


大厂尤其看重这部分。

- **数据结构**：数组、链表、栈、队列、哈希表、树（特别是二叉树）。要能理解其概念并知道在 JS 中如何实现。
- **算法**：
	- 排序算法（冒泡、快排）。
	- 查找算法（二分查找）。
	- 树的遍历（深度优先 DFS, 广度优先 BFS），这在处理 DOM 树时很常见。
	- LeetCode 上的简单和中等难度的题目，特别是字符串和数组相关的。
- **设计模式**：单例模式、工厂模式、观察者模式（发布-订阅）、装饰器模式等在前端中的应用。

## 在浏览器中输入地址回车后会发生什么


从输入 URL到页面展示的全过程（DNS 查询 -> TCP 握手 -> HTTP 请求 -> 解析 HTML -> 构建 DOM 树 -> 构建 CSSOM 树 -> 构建渲染树 -> 布局 -> 绘制）


## 项目中的图片懒加载怎么实现


**方法一：浏览器原生懒加载 (****`loading="lazy"`****) - 推荐首选**


经我的实验验证，确实有用，但是条件很宽松，离视口很远的话才会触发懒加载不是不在视口就懒加载，而且听说网络条件好也会直接加载。缺点不好控制细节行为。


**方法二：使用 JavaScript** **`IntersectionObserver`** **API - 最灵活、最推荐的自定义方案**


不要将真实的图片地址放在 **`src`** 中，而是放在一个自定义的 **`data-src`** 属性里。**`src`** 可以放一个占位图，或者留空。监听视口轮到图片就挂上。


**方法三：基于** **`scroll`** **事件监听 +** **`getBoundingClientRect()`** **- 传统方法**


## **`[] == ![]`** **为什么是** **`true`****？**


解析（这是隐式转换规则（特别是 == 和 +）与 显式转换方法的问题）：

1. **`![]`**：首先计算 **`!`** 运算符。**`[]`** 是一个对象，在布尔上下文中是 **`true`**。所以 **`![]`** 就是 **`false`**。
2. 表达式变为：**`[] == false`**。
3. 根据规则 **`boolean == 任何类型`**，将 **`boolean`** 转换为 **`number`**。**`false`** 转换为 **`0`**。
4. 表达式变为：**`[] == 0`**。
5. 根据规则 **`对象 == number`**，将对象 **`[]`** 通过 **`ToPrimitive`** 转换为原始值。提示是 **`number`**。
	- 调用 **`[].valueOf()`**，返回 **`[]`** 本身（不是原始值）。
	- 继续调用 **`[].toString()`**，返回 **`''`**（空字符串）。
6. 表达式变为：**`'' == 0`**。
7. 根据规则 **`string == number`**，将 **`string`** 转换为 **`number`**。**`''`** 转换为 **`0`**。
8. 表达式变为：**`0 == 0`**。
9. 结果：**`true`**。

## 闭包 (Closure)是什么


当一个函数能够记住并访问它所在的词法作用域时，就产生了闭包，即使函数是在其当前词法作用域之外执行的。


当你（函数）离开房间（词法作用域）去别的地方执行时，这个背包让你依然能访问到房间里的那些物品（变量）。


```typescript
function makeCounter() {
  let count = 0; // count 位于 makeCounter 的词法作用域内

  // 这个内部函数就是一个闭包
  return function() {
    count++; // 它可以访问并修改外部作用域的 count 变量
    return count;
  };
}
```


调用函数后，返回匿名函数，虽然理论要销毁 count 这个变量，因为匿名函数和原来词法作用域里的变量仍然有联系引用，通过垃圾回收机制不去回收联系的变量，这样变量就被封闭住了。


**优点：**


1.提供私有变量，实现数据封装和隐藏
2.让变量的状态得以持久化



**应用场景：**


防抖节流模块化


缺点：内存泄漏，因为不怎么回收


## **执行上下文 (Execution Context) 与调用栈 (Call Stack)**


JavaScript 代码执行的底层机制：**执行上下文** 和 **调用栈**。
**执行上下文：**每当一段代码准备执行时，JS 引擎都会为它创建一个执行上下文。


执行上下文主要有三种：**1.全局执行上下文 2.函数执行上下文 3.Eval函数执行上下文**


创建阶段：


1.**创建词法环境**

- 它记录了当前作用域内的所有**变量、函数声明**以及**对外部环境的引用**（这就是作用域链的基础）。
- 对于 **`let`** 和 **`const`** 声明的变量，它们会被创建但**不会被初始化**，处于“未初始化”状态。这就是为什么在声明前访问它们会报错（暂时性死区，TDZ）。
- 对于 **`function`** 声明，它会被**完整创建并初始化**，这就是为什么函数声明可以在定义之前被调用（函数提升）。

tips:


**`let`** **和** **`const`** **定义的函数（即函数表达式）不会被“完整地”提升，但它们声明的变量会被提升进入“暂时性死区”。**


**不可以在声明之前调用!**


2.**确定** **`this`** **的指向**



执行阶段
在准备工作完成后，代码开始一行一行地执行。


## 深拷贝浅拷贝


核心：其实就是能不能完全把对象嵌套的属性也给复制过去的问题。


**浅拷贝（只能拷贝一层 更深的还是引用的地址 不是完全拷贝）：**


1.**`Object.assign()`**


```typescript
let originalObj = {
  name: '张三',
  age: 25,
  hobbies: ['读书', '游泳']
};

// 使用 Object.assign 进行浅拷贝
let shallowCopy = Object.assign({}, originalObj);

// 修改原始类型的值
shallowCopy.name = '李四';
console.log(originalObj.name); // '张三' (不受影响)

// 修改引用类型的值
shallowCopy.hobbies.push('跑步');
console.log(originalObj.hobbies); // ['读书', '游泳', '跑步'] (被影响了！)
```


2.扩展运算符 `...` 


3.**`Array.prototype.slice()`** **或** **`Array.from()`**


**深拷贝（完全拷贝，更深的嵌套属性此刻也不是原引用了独立起来了）：**


1.`JSON.parse(JSON.stringify(obj))` (简单但有缺陷)


2.递归函数 (最根本的解决方案)


3.现代浏览器内置方法 `structuredClone()` (推荐)


其实还得最后看polyfill一下 这个有点太新了貌似


4.使用第三方库 (如 Lodash)


cloneDeep


```typescript
// 需要先安装 lodash: npm install lodash
import { cloneDeep } from 'lodash';

let originalObj = { /* ... */ };
let deepCopy = cloneDeep(originalObj);
```


### **总结与对比**


| **方法**                     | **类型**  | **能否处理嵌套对象** | **优点**           | **缺点**             |
| -------------------------- | ------- | ------------ | ---------------- | ------------------ |
| **`Object.assign()`**      | 浅拷贝     | 否            | 简单               | 嵌套对象会共享引用          |
| 扩展运算符 **`...`**            | 浅拷贝     | 否            | 语法简洁，ES6 标准      | 嵌套对象会共享引用          |
| **`JSON.parse/stringify`** | 深拷贝     | 能            | 简单快捷             | 类型丢失多，无法处理函数、循环引用  |
| **递归函数**                   | **深拷贝** | **能**        | **可自定义，理解原理**    | **实现复杂，需考虑各种边界情况** |
| **`structuredClone()`**    | **深拷贝** | **能**        | **原生API，强大，性能好** | **无法拷贝函数、原型链**     |
| **Lodash** **`cloneDeep`** | **深拷贝** | **能**        | **最健壮，功能最全**     | **增加项目体积**         |


## MAP/SET


| 特性         | Set     | Map         |
| ---------- | ------- | ----------- |
| 是否存键值对     | ❌ 只有值   | ✅ key-value |
| key 是否能是对象 | —       | ✅ 任意类型      |
| value 是否唯一 | ✅ 自动去重  | ❌ 可重复       |
| 是否按插入顺序遍历  | ✅       | ✅           |
| 性能（查找/删除）  | 快       | 快           |
| 常用用途       | 去重、集合运算 | 字典、缓存、映射    |


### **WeakMap**

- key 必须是对象
- 对象会被自动垃圾回收
- 用于缓存、存储私有数据

### **WeakSet**

- 值必须是对象
- 热门用途：存储对象是否处理过

## 前端算法解析


指南：


### 💡 第一梯队：必考基础（保命题）


**这一类最常见，考的是你对 JS 语言特性的熟悉程度。如果不写出来，面试官会觉得基础不牢。**

1. **防抖 (Debounce) & 节流 (Throttle)**
	- _作用：_ 限制事件触发频率（点太快了不行）。
	- _状态：_ ✅ 你已经看过了。
2. **深拷贝 (Deep Clone)**
	- _作用：_ 复制一个对象，彻底切断与原对象的联系。
	- _状态：_ ✅ 你已经看过了。
3. **数组扁平化 (Array Flatten)**
	- _作用：_ 把多维数组变成一维数组。
	- _状态：_ ✅ 你已经看过了。
4. **手写** **`call`****、****`apply`****、****`bind`**
	- _作用：_ 手动改变函数执行时的 `this` 指向。
	- _难度：_ ⭐⭐（逻辑和 `new` 有点像）。
5. **数组去重 (Array Unique)**
	- _作用：_ 数组里重复的数字去掉。
	- _难度：_ ⭐（非常简单，通常用 `Set` 一行代码解决，但面试官可能会让你用老办法写）。

---


### 🚀 第二梯队：工程实战（加分题）


**这一类考的是“解决实际问题的能力”，大厂特别喜欢考。**

1. **发布订阅模式 (Event Emitter)** 🔥 _极高频_
	- _描述：_ 实现 `on`（订阅）、`emit`（发布）、`off`（取消）。类似于 Vue 的 `$on` 和 `$emit`。
	- _场景：_ 组件通信。
2. **解析 URL 参数 (Parse URL)**
	- _描述：_ 把网址后面的 `?name=jack&age=18` 变成对象 `{ name: 'jack', age: '18' }`。
	- _场景：_ 页面跳转传参处理。
3. **手写 Promise.all**
	- _描述：_ 给你一堆请求，等它们**全部**完成了再返回；如果有一个失败了就直接报错。
	- _场景：_ 同时加载多个接口数据。
4. **图片懒加载 (Lazy Load)**
	- _描述：_ 图片滚到屏幕里了再加载。
	- _场景：_ 性能优化。
5. **列表转树结构 (List to Tree)**
	- _描述：_ 后端给你一个平铺的数组（带 parentId），你要把它转成树形结构（children）。
	- _场景：_ 菜单栏、权限树。

---


### 🧠 第三梯队：算法与进阶（大厂核心题）


**如果你面的是字节、阿里、腾讯，或者高级岗位，这一类是拉开差距的关键。**

1. **并发控制 (Scheduler)**
	- _状态：_ ✅ 你已经看过了（那个银行柜台排队的题）。
2. **手写 Promise 完整版**
	- _描述：_ 从零实现一个 Promise Class。
	- _难度：_ ⭐⭐⭐⭐⭐（非常繁琐，建议最后再看，性价比不高）。
3. **LRU 缓存算法**
	- _描述：_ 内存有限，新数据来了，把“最久没用过”的老数据删掉。
	- _场景：_ 浏览器的缓存机制、Vue 的 `<keep-alive>` 原理。
4. **柯里化 (Currying)**
	- _描述：_ 把 `add(1, 2, 3)` 变成 `add(1)(2)(3)` 的形式。
	- _场景：_ 函数式编程。

### 1.防抖


```typescript
function debounce(fn,delay){
    let timer=null;
    return function(...args){
        const context=this;
        if(timer){
            clearTimeout(timer)
        }
        setTimeout(() => {
            fn.apply(context,args)
        }, delay);
    }
}
```


主要几个模块，定时器,this,和回调


**其中this一直很难懂 但是我发现有点懂了**


```typescript
const input = document.querySelector('input');

input.addEventListener('input', debounce(function() {
  console.log(this);        // 我们希望这里是 input 这个 DOM 元素
  console.log(this.value);  // 希望能直接拿到输入框的值
}, 300));
//其中本来的监听回调现在是有两层函数一层debounce一层定时函数里的函数
```


普通函数this是运行时候确认的，这里有个标准不带防抖版


```typescript
document.querySelector("button").addEventListener("click", function () {
        console.log(this); //正常输出元素
});
```


但是防抖现在是相当于**回调的上一层（是正常时候的唯一函数层）**这时候是有正确this的 回调是没有的 所以必须存储一下 我们真正执行的函数层被防抖包裹了一层实际上是里层获取不到外层本来能得到的this了


## 2.扁平化数组


```typescript
let arr = [[23, 32321], [2313], 23];
const flatten = (arr) => {
  return arr.reduce((prev, curr) => {
    const next = Array.isArray(curr) ? flatten(curr) : curr;
    return prev.concat(next);
  }, []);
};
console.log(flatten(arr));
//output:[ 23, 32321, 2313, 23 ]
```


## 3.深拷贝


```typescript
// map 用来记录已经拷贝过的对象，防止死循环（比如 A 里面引用了 A）。
function deepClone(obj, map = new WeakMap()) {
  
  // 1. 基础类型出口。
  // 如果是 null 或者不是对象（是数字、字符串），不用拷贝，直接返回。
  if (obj === null || typeof obj !== 'object') return obj;
  
  // 2. 查表（防循环引用）。
  // 看看 map 记录本里，这个 obj 是不是之前已经拷贝过了？
  // 如果拷贝过，直接把上次拷贝的结果拿出来，不要再递归了。
  if (map.has(obj)) return map.get(obj);
  
  // 3. 创建新容器。
  // 如果 obj 是数组，就 new Array()，是对象就 new Object()。
  // obj.constructor 就能自动找到它是数组还是对象。
  const newObj = new obj.constructor();
  
  // 4. 记录备案。
  // 把原对象(obj)和新对象(newObj)的关系记下来，防止下次再遇到死循环。
  map.set(obj, newObj);
  
  // 5. 遍历属性。
  // 把 obj 里的每一个 key 都拿出来。
  for (const key in obj) {
    // 只拷贝对象自己的属性，不拷贝原型链上的。
    if (obj.hasOwnProperty(key)) {
      // 6. 递归关键！
      // 属性的值 (obj[key]) 可能还是个对象，所以要再次调用 deepClone。
      // 把结果赋值给新对象。
      newObj[key] = deepClone(obj[key], map);
    }
  }
  
  return newObj;
}
```


## MAP的作用：**防止“循环引用”导致的死循环**。

暗黑模式 CSS 方案


这个我一时半会竟然想不到 想到的最简单的CSS文件切换


**核心方案：CSS 变量 + 类名切换**


这是目前最主流、最推荐的方案。它将颜色主题与组件逻辑解耦，维护成本极低，切换性能也非常高（因为只是修改一个根元素的属性）。


**1. 定义颜色变量**


在 **`:root`**（代表文档根元素 **`<html>`**）中定义默认（亮色）主题的颜色。


```css
/* :root 中的变量是全局默认值（亮色主题） */
:root {
  --bg-color: #ffffff;
  --text-color: #333333;
  --card-bg-color: #f4f4f4;
  --border-color: #dddddd;
  --primary-color: #007bff;
}
```


**2. 定义暗黑主题的颜色**


使用一个属性选择器（如 **`[data-theme='dark']`**）来覆盖默认变量，定义暗黑主题的颜色。


```css
/* 当 html 标签有 data-theme="dark" 属性时，应用这些变量值 */
[data-theme='dark'] {
  --bg-color: #121212;
  --text-color: #e0e0e0;
  --card-bg-color: #1e1e1e;
  --border-color: #333333;
  --primary-color: #4dabf7;
}
```


**3. 在组件中使用变量**


在所有需要根据主题变化颜色的地方，使用 **`var()`** 函数来引用变量。


```css
body {
  background-color: var(--bg-color);
  color: var(--text-color);
  transition: background-color 0.3s ease, color 0.3s ease; /* 添加平滑过渡效果 */
}

.card {
  background-color: var(--card-bg-color);
  border: 1px solid var(--border-color);
}

.button-primary {
  background-color: var(--primary-color);
}
```


**4. JavaScript 切换逻辑**


编写一个简单的 JS 函数来切换 **`<html>`** 元素的 **`data-theme`** 属性。

- **CSS 硬件加速**：切换主题只是改变一个 HTML 属性，浏览器会高效地重新计算样式并触发重绘，这个过程非常快。
- **避免 JS 操作样式**：我们不需要用 JS 遍历所有元素并逐个修改 **`style`**，这避免了昂贵的 DOM 操作和大量的回流/重绘。
- **CSS 变量的优势**：CSS 变量的更新是“继承式”的，修改根部的变量，所有后代引用该变量的地方都会自动更新，效率极高。

## **性能优化100000条数据**


通常指在前端渲染一个包含10万个项目的列表或表格。直接渲染10万个 DOM 元素是绝对不可行的，会导致页面瞬间卡死。核心思想是：**永远不要渲染你看不见的东西**。

**核心策略：虚拟滚动**

1. **计算可见区域**：容器有一个固定的高度，滚动时，计算出当前滚动条位置对应的应该显示的数据项的起始索引（**`startIndex`**）和结束索引（**`endIndex`**）。
2. **动态渲染**：只渲染 **`startIndex`** 到 **`endIndex`** 之间的数据项。
3. **撑开容器**：为了保持滚动条的正确比例，容器内部会有一个总高度为 **`itemHeight * totalCount`** 的“占位元素”。可见的列表项通过 **`transform: translateY()`** 来定位到正确的位置。
4. **分页**
	- **原理**：最简单粗暴的方法。将数据分成多页，用户通过点击页码来加载不同页的数据。
	- **优点**：实现简单，服务器和前端压力都小。
	- **缺点**：用户体验不连贯，无法快速浏览所有数据。
5. **无限滚动**
	- **原理**：用户滚动到底部时，通过 AJAX 加载下一页的数据，并追加到现有列表中。
	- **优点**：用户体验流畅，符合现代 Web 习惯。
	- **缺点**：如果一直滚动，DOM 节点会越来越多，最终还是会变慢。**（因此，对于超大数据，无限滚动必须结合虚拟滚动）**。
6. **Web Worker**
	- **场景**：当对这10万条数据进行复杂计算时（如搜索、过滤、排序），会阻塞主线程，导致页面卡顿。
	- **解决方案**：将这些计算密集型任务放到 Web Worker 中执行。Worker 在后台线程中运行，计算完成后将结果通过 **`postMessage`** 发回主线程，主线程再进行渲染。这样 UI 就不会被阻塞。

## 简单的双向绑定（响应式原理）


```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <label>姓名:</label
    ><input type="text" class="name" onchange="changeName(this)" />
    <button onclick="changeInput()">恢复姓名为rose</button>
    <script>
      let person = {
        _name: "",
      };
      const input = document.querySelector(".name");
      Object.defineProperty(person, "name", {
        enumerable: true,
        configurable: true,
        //默认给false 需要手动设定true
        get() {
          return this._name;
        },
        set(newval) {
          console.log("setting");
          if (newval == this._name) {
            return;
          }
          this._name = newval;
          input.value = newval;
        },
      });
      function changeName(el) {
        person.name = el.value;
      }
    </script>
  </body>
</html>

```


这里有个小小的坑，就是字面`_name`实际上是一个临时属性，把`name`的拦截挂到这里可以**防止递归**，然后获取的时候通过`_name`值获取，`name`只是一个挂号，实际的值在`_name`上。真正的name没写在字面量上。


## 有let了吗 iife还有用


iife主要解决var作用域的问题


### 经典问题


```javascript
// 使用 var 的问题
var funcs = [];
for (var i = 0; i < 3; i++) {
  funcs[i] = function() {
    console.log(i); // 所有函数都会打印 3
  };
}
funcs[0](); // 3
funcs[1](); // 3
funcs[2](); // 3
```


解决方法：


通过 IIFE 为每次循环创建一个新的函数作用域，将 **`i`** 的值“锁定”在内部。


```javascript
// 使用 IIFE 解决
var funcs = [];
for (var i = 0; i < 3; i++) {
  (function(index) {
    funcs[index] = function() {
      console.log(index); // 0, 1, 2
    };
  })(i);
}
funcs[0](); // 0
funcs[1](); // 1
funcs[2](); // 2
```


| 特性/场景                | `let` / `const` | IIFE            |
| -------------------- | --------------- | --------------- |
| **主要目的**             | 声明块级作用域变量       | 创建独立的函数作用域并立即执行 |
| **解决循环问题**           | ✅ **首选，代码简洁**   | ✅ (旧方法)         |
| **创建私有变量/模块**        | ❌ (无法单独实现)      | ✅ **核心用途**      |
| **避免全局污染**           | ✅ (在模块化文件中)     | ✅ **非常强大**      |
| **立即执行初始化代码**        | ❌ (需要额外调用)      | ✅ **天生如此**      |
| **传递参数（如window, $）** | ❌ (无法直接实现)      | ✅ **非常方便**      |


##  Vue设计模式


### 发布订阅模式


**引入一个中间人（调度中心），让发布者和订阅者完全解耦，双方不直接通信。**


调度中心是这个模式的核心，它的内部实现非常简单：

1. **数据结构**：调度中心的核心通常是一个**对象（或字典/Map）**。
	- 这个对象的 **`key`** 是**事件/主题的名称**（例如：**`'news'`**, **`'sports'`**）。
	- 这个对象的 **`value`** 是一个**数组**，存放着所有订阅了这个主题的**回调函数**（订阅者的处理逻
2. **两个核心方法**：
	- **`subscribe(event, callback)`**：订阅方法。
		- 接收一个事件名 **`event`** 和一个回调函数 **`callback`**。
		- 将这个 **`callback`** 添加到 **`events[event]`** 数组中。如果这个 **`event`** 还不存在，就先创建一个空数组。
	- **`publish(event, data)`**：发布方法。
		- 接收一个事件名 **`event`** 和要发送的数据 **`data`**。
		- 在 **`events`** 对象中找到 **`event`** 对应的数组。
		- **遍历**这个数组，并**依次执行**里面所有的回调函数，把 **`data`** 作为参数传进去。

**1. 核心响应式系统**


这是 Vue 最核心的发布订阅模式实现。

- **发布者**: Vue 组件中的 **`data`** 属性。当这些数据发生变化时，它们就“发布”了一个变更通知。
- **订阅者**: 依赖这些数据的 DOM 部分（模板）、计算属性（**`computed`**）和侦听器（**`watcher`**）。它们在组件渲染时会“订阅”自己所依赖的数据。
- **调度中心**: Vue 内部的依赖收集和通知系统。

伪代码：


```javascript
#b站订阅例子
事件中心：B站服务器
// B站消息中心
const Bilibili = {
    channels: {
       '今天没准备儿':[(fan1),(fan2),(fan3)]
    },   // 记录：UP 主 -> 粉丝回调列表
         // record:data -> DOM依赖

    subscribe(up, fanCallback) {
        if (!this.channels[up]) {
            this.channels[up] = [];
        }
        //将依赖dom推送到所依赖的data节点里
        this.channels[up].push(fanCallback);
    },

    publish(up, newVideo) {
        const fans = this.channels[up];
        if (!fans) return;

        // 给所有粉丝推送消息
        // 给所有依赖dom发消息 让他们响应式改变
        fans.forEach(callback => callback(newVideo));
    }
};
// 小明关注了 某UP主
// 某dom节点订阅了 某data数据
Bilibili.subscribe("LexBurner", (video) => {
    console.log("小明收到推送:", video.title);
});

// 小红也关注了
Bilibili.subscribe("LexBurner", (video) => {
    console.log("小红收到推送:", video.title);
});
// UP主发布新视频
Bilibili.publish("LexBurner", {
    title: "《我又发新视频啦！》",
    url: "/video/BV123456"
});
//小明收到推送: 《我又发新视频啦！》
//小红收到推送: 《我又发新视频啦！》

```


**工作流程**:

1. 当组件渲染时，Vue 会记录下模板中用到了哪些 **`data`** 属性（这个过程叫**依赖收集**）。
2. 当某个 **`data`** 属性被修改时，Vue 会通知所有订阅了该属性的“订阅者”。
3. 订阅者收到通知后，会自动更新 DOM 或重新计算计算属性的值。

**2. 组件间通信 - 自定义事件**


这是非常直观的发布订阅模式，常用于父子组件通信。

- **发布者**: 子组件通过 **`this.$emit('my-event', data)`** 发布一个名为 **`my-event`** 的事件。
- **订阅者**: 父组件在模板中使用 **`<child-component @my-event="parentMethod" />`** 来订阅这个事件。
- **调度中心**: Vue 的组件实例本身，它内置了 **`$on`**, **`$emit`**, **`$off`** 等方法来管理事件。

**3. 全局事件总线**


在 Vue 2 中，这是一种常见的跨组件通信方式，它和你写的 **`PubSub`** 类几乎一模一样。

- **实现**: 通常创建一个独立的 Vue 实例作为事件总线。
- **发布**: 在任何组件中，**`EventBus.$emit('event-name', data)`**。
- **订阅**: 在任何组件中，**`EventBus.$on('event-name', callback)`**。

**注意**: 在 Vue 3 中，移除了 **`$on`**, **`$off`** 等实例方法，官方推荐使用像 [**Mitt**](https://github.com/developit/mitt) 这样的第三方库来实现事件总线，或者使用状态管理库。


**4. 状态管理库**


无论是 Vuex (Vue 2/3) 还是 Pinia (Vue 3 推荐)，它们的核心都是一个巨大的、集中式的发布订阅系统。

- **发布者**: 组件通过 **`dispatch`** 一个 **`action`** 或 **`commit`** 一个 **`mutation`** 来发布一个“状态变更”的意图。
- **订阅者**: 所有在模板或计算属性中使用了该 **`state`** 的组件。
- **调度中心**: Vuex 或 Pinia 的 Store。它接收变更请求，更新 **`state`**，然后通知所有订阅者更新。

### **观察者模式**


这与发布订阅模式非常相似，但有一个关键区别：在观察者模式中，**发布者（被观察者）会直接维护一个订阅者（观察者）列表**。而在发布订阅模式中，发布者和订阅者之间有一个独立的“调度中心”。

- **应用**: Vue 的响应式系统在底层更接近观察者模式。每个响应式对象都有一个 **`Dep`** 类（Dependency）的实例，它存储了所有订阅它的 **`Watcher`** 实例。当数据变化时，**`Dep`** 会直接通知它内部的 **`Watcher`** 列表。

### **单例模式**


确保一个类只有一个实例，并提供一个全局访问点。


js实现思想：

- **检查**：判断那个静态变量是否已经有值。
- **创建**：如果为空（即实例还未被创建），就调用 **`new`** 来创建一个新的实例，并存入静态变量中。
- **返回**：如果已经有值，直接返回这个已经存在的实例。
- **应用**:
	- **应用实例**: **`new Vue()`** (Vue 2) 或 **`createApp()`** (Vue 3) 创建的应用实例通常是单例。
	- **Vuex/Pinia Store**: 整个应用通常只有一个全局的 Store 实例。
	- **Vue Router**: 路由器实例也是单例的。

### **工厂模式**


**将创建对象的过程封装起来，客户端不直接通过** **`new`** **来创建对象，而是通过一个“工厂”来获取所需的对象。**


```javascript
//传统模式
// 1. 定义产品类
class Car {
  drive() {
    console.log('驾驶小汽车...');
  }
}

class Bike {
  drive() {
    console.log('骑自行车...');
  }
}

// 2. 客户端代码 - 直接创建
function createVehicleAndDrive(type) {
  let myVehicle;

  // 客户端需要知道所有具体的类名，并负责创建逻辑
  if (type === 'car') {
    myVehicle = new Car();
  } else if (type === 'bike') {
    myVehicle = new Bike();
  }

  myVehicle.drive();
}

createVehicleAndDrive('car'); // 输出: 驾驶小汽车...

// 工厂模式 （把之前的逻辑提前封装）
class VehicleFactory {
  createProduct(type) {
    if (type === 'car') {
      return new Car(); // 创建小汽车
    } else if (type === 'bike') {
      return new Bike(); // 创建自行车
    }
    return null;
  }
}
```

- **应用**: Vue 的 **`createElement`** 方法（或 **`h`** 函数）就是一个典型的工厂。它负责创建虚拟 DOM 节点 (VNode)。你不需要关心 **`VNode`** 是如何被具体创建的，只需要调用这个工厂函数并传入参数即可。

### **代理模式**


为一个对象提供一个代用品或占位符，以控制对这个对象的访问。

- **应用**: 这是 **Vue 3 响应式系统的核心**。当你使用 **`reactive()`** 或 **`ref()`** 创建一个响应式对象时，Vue 会返回一个原始对象的**代理**。你对这个代理的任何操作（如读取、修改属性）都会被 JavaScript 的 **`Proxy`** API 拦截，从而使 Vue 能够在这些操作发生时执行依赖收集和触发更新等逻辑。

### **组合模式**


将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

- **应用**: Vue 的**组件系统**本身就是组合模式的完美体现。一个组件可以包含多个子组件，形成一个组件树。你可以像处理单个组件一样处理整个组件树（例如，渲染一个父组件，就会递归地渲染它所有的子组件）。

## 前端一些新技术


面试用- -


### **React Server Component**


React Server Component（简称 RSC）是一种新型 React 组件，它专为在服务器端渲染而设计，与传统的客户端组件不同，RSC 的代码不会被打包发送到浏览器，而是直接在服务器上执行并生成 HTML 发送给客户端。这使得它能够直接访问服务器资源（如数据库），从而减少客户端 JavaScript 捆绑包的大小，提高应用性能和加载速度。


RSC 是 React 生态中一项重大范式转变，它将组件分为两类：**服务器组件**（默认）和**客户端组件**（需用 'use client' 标记）。服务器组件在服务器上一次性渲染，不参与客户端的水合（hydration）过程，因此它们更轻量且高效，适合处理静态内容或数据密集型逻辑。


**主要优势**：

- **性能优化**：零客户端 JS 开销，减少捆绑包大小（可达 90% 以上减少）。
- **数据获取**：直接在组件中调用服务器 API，无需额外网络请求。请求后直接包裹在html模板。
- **安全性**：敏感逻辑（如 API 密钥）保持在服务器端。

### **“信号式”响应式**


与传统的虚拟 DOM（Virtual DOM）模型不同，信号式响应式不依赖运行时 diffing（差异比较），而是直接追踪数据依赖关系，只在真正变化的部分触发 DOM 更新


为什么更精细、高性能？
信号追踪依赖图变化传播如涟漪，只波及下游节点。相比虚拟 DOM 的“树遍历”，这减少 90%+ 的无谓计算。在 JS Framework Benchmark（2025 数据），Solid.js/Qwik/Svelte 5 的运行时速度是 React 的 2-3 倍，内存使用低 50%。


虚拟dom→信号式


在 2010 年代初，前端开发面临一个核心痛点：真实 DOM 操作昂贵且低效。浏览器中的真实 DOM（Document Object Model）是一个树状结构，每次修改（如添加/删除元素、更改属性）都会触发重绘（reflow）和重排（repaint），这在复杂、动态 UI（如 Facebook 的新闻 feed）中会导致性能瓶颈——频繁更新可能让页面卡顿，甚至崩溃。


**总结：更改一次就会回流一次太卡了 直接用虚拟dom算完了一次回流**


信号式不会面对真实 DOM 操作昂贵且低效？

- **原生DOM操作 (jQuery时代)**：**一个拿着大锤的工人**。你想把墙上的一颗钉子敲进去一点，他抡起大锤，“哐”地一下砸在墙上。虽然钉子动了，但整面墙都在震。如果你让他敲100下，墙可能就塌了（页面卡顿）。这个过程是**手动、粗暴、且容易误伤**的。
- **虚拟DOM (React/Vue)**：**一个聪明的建筑师团队**。每次你想修改房子，他们不会直接动工。而是先在图纸上画一个新设计（新VDOM树），然后和旧图纸对比，找出所有需要修改的地方。最后，工头会拿着一份清单，指挥工人一次性、高效地把所有改动做完。这个过程是**批量、优化过的**，但每次都需要“重新画图纸”和“对比图纸”的成本。
- **信号式响应式**：**一个拥有精密传感器的智能家居系统**。系统里每个设备（UI节点）都知道自己依赖于哪个传感器（信号）。比如，客厅的灯（**`<p>`**标签）只连接到“亮度传感器”（**`count`**信号）。当“亮度传感器”的数值变化时，系统**只**会向客厅的灯发送指令，让它调整亮度。其他房间的设备（空调、电视）完全不受影响。这个过程是**自动、精准、且影响范围最小**的。

**核心秘诀：高细粒度/隐式的订阅关系**


**1. 细粒度订阅**


```javascript
// Solid.js 示例
const count = signal(0);

// 在JSX中读取信号
function Counter() {
  return (
    <div>
      <p>Count: {count()}</p>  // <p> 标签订阅了 count 信号
      <button onClick={() => count.value++}>Increment</button>
    </div>
  );
}
```


框架在初次渲染时，会建立一个**隐式的订阅关系**：**`<p>`** 这个DOM节点里的文本内容，订阅了 **`count`** 这个信号。这个关系是**精确到DOM节点级别**的，而不是组件级别。



**2.直接、最小化更新**


当你点击按钮，**`count.value`** 变化时，会发生什么？

- **没有组件重新渲染**：**`Counter`** 函数**不会**被重新执行。
- **没有VDOM Diff**：框架**不会**创建新的虚拟DOM树来进行比较。
- **直接更新**：**`count`** 信号会通知所有订阅了它的地方。在这个例子里，它只会通知那个 **`<p>`** 标签。然后框架会执行一个**极其轻量级**的操作，类似于 **`p.textContent = "Count: 1"`**。

这个操作的开销，远小于“重新执行组件函数 + Diff算法 + 批量Patch”的总和。


**3. 批量更新**


优秀的信号式框架（如Solid.js）会处理这个问题。它会将同一个微任务队列中的所有DOM更新**收集起来，然后一次性、按顺序地应用到真实DOM上**。这避免了“布局抖动”，确保了性能，和虚拟DOM的批量更新有异曲同工之妙，但它的决策依据是“哪些信号变了”，而不是“新旧VDOM树哪里不同”。
核心：对比订阅列表


| 特性        | 原生DOM操作 (jQuery)                       | 虚拟DOM                               | 信号式响应式                          |
| --------- | -------------------------------------- | ----------------------------------- | ------------------------------- |
| **更新范围**  | **开发者手动决定**，容易过大，引发不必要的Reflow/Repaint。 | **组件级别**。一个状态变化可能导致整个组件树被重新渲染和Diff。 | **DOM节点级别**。只更新真正依赖该数据的DOM部分。   |
| **决策开销**  | **无**，直接操作，但决策本身容易出错。                  | **高**。每次更新都需要重新执行组件函数和运行Diff算法。     | **极低**。信号变化时，直接通过订阅关系找到目标，无需计算。 |
| **DOM操作** | **频繁、零散、不可预测**。                        | **批量、优化后**。但可能更新了并未改变的部分。           | **最小化、精准、批量**。理论上只更新绝对必要的部分。    |
| **心智模型**  | 命令式："我命令你改变这个元素"。                      | 声明式："UI是状态的函数，状态变了UI就变"。            | 声明式："这个UI依赖这个数据，数据变了UI自动变"。     |

