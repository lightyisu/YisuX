---
catalog:
  - jishu
date: '2025-12-06 08:00:00'
type: Post
slug: liti
title: 面试 | 前端例题记录
status: 已发布
urlname: 2c1e9dc9-c245-8004-9b92-dd655c65e05b
updated: '2026-01-16 14:55:00'
---

## 题目1

1. 请你按照以下要求处理以上的字符串对象 data，
    - 以上字符串开头中的星期字符串大小写混乱了，请你先统一格式化它们，确保星期为首字母大写，其余字母小写。比如 `"Monday","Tuesday"`
    - 请您将字符串中符号（"-"） 都替换为冒号（":"）
    - 请您确保每一个字符串都是以单位 ml 结尾，有些字符串没有带毫升(ml)单位,请您添加上

```javascript
const data = [
  "monday - 500ml",
  "mONday - 330",
  "monday - 150ml",
  "Tuesday - 100ml",
  "Tuesday - 330ml",
  "weDnesDay - 230",
  "TursDAy - 330ml",
  "Friday - 500",
  "Saturday - 100ml",
  "sunday - 250",
  "sunday - 100ml",
];
let newdatat = data.map((item) => {
  let temp = item.charAt(0).toUpperCase() + item.slice(1).toLowerCase();
  temp = temp.replace("-", ":");
  if (temp.indexOf("ml") == "-1") {
    temp = temp.concat("ml");
  }
  return temp;
});
console.log(newdatat);
```

1. 实现某一天饮水信息检索功能。允许用户在搜索输入键入星期数来搜索数据 data 中某一天的饮水信息。
    - 搜索应该不区分大小写（因此，输入 `MONDAY`，应自动过滤为 `monday`）。
    - 此外，应该忽略搜索输入中的前导和尾随空格。
    - 搜索 moday 应当返回所有包含 monday 的字符串,如下所示：

```javascript
let query = (day, data = newdata) => {
  day = day.toLowerCase().trim();
  day = day[0].toUpperCase() + day.slice(1);
  let query_data = data.filter((item) => item.indexOf(day) != -1);
  console.log(query_data);
};
query(" Tuesday   ");
```

1. 基于上一个任务检索出来的字符串结果，计算这一天的饮水总量，并且告知用户饮水是否达标。要求饮水 500ml 以上就算达标。
    - 截取每一个字符串末尾数字内容（倒数第五位至倒数第三位）
    - 计算数字总和（需要将字符串转换为数字类型）
    - 如果饮水总量没有达到 500ml 就弹出信息`您在星期 x 的饮水量没有达标！` ，否则就提示`您在星期 x 的饮水量达标啦！`

```javascript
let query = (day, data = newdata) => {
  day = day.toLowerCase().trim();
  day = day[0].toUpperCase() + day.slice(1);
  let query_data = data.filter((item) => item.indexOf(day) != -1);
  console.log(query_data);
  let total_water = 0;
  query_data.forEach((item) => {
    water = Number(item.slice(-5, -2));
    total_water += water;
  });

  if (total_water < 500) {
    console.log("no you need more water");
  } else {
    console.log("you pass");
  }
};
```


## 回文检查


```javascript
/**
* @param {string} str
* @return {Boolean} 如果是返回 true，如果不是回文字符串 返回 false
*/
function isPalindromicString(str) {
  // 将字符串反转
  const reversedStr = str.split('').reverse().join('');
  // 比较原字符串和反转后的字符串
  return str === reversedStr;
}

// 测试用例
console.log(isPalindromicString("aaa")); // ->true
console.log(isPalindromicString("madam")); // ->true
console.log(isPalindromicString("hello")); // ->false
console.log(isPalindromicString("")); // ->true (空字符串是回文)
console.log(isPalindromicString("a")); // ->true (单个字符是回文)
```


## 打字机


```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <label>请输入文本:</label><input type="text" />
    <button onclick="generateTypeEffect()">生成打字效果</button>
    <h2 id="showText"></h2>
    <script>
      function generateTypeEffect() {
        let text = document.querySelector("input").value;
        const h2 = document.querySelector("#showText");
        console.log(text);
        for (let i = 0; i < text.length; i++) {
          setTimeout(() => {
            h2.innerHTML = text.slice(0, i + 1);
            console.log(text.slice(0, i + 1));
          }, i * 1000);
        }
      }
    </script>
  </body>
</html>
```


## 发布订阅模式


```javascript
class PubSub{
    constructor(){
        this.events={}
    }
    subscibe(event,callback){
        if(!this.events[event]){
            this.events[event]=[]
        }
        this.events[event].push(callback)
        //返回一个函数用于后续取消订阅
        return ()=>{
            this.events[event]=this.events[event].filter(cb=>cb!==callback)
        }
    }
    publish(event,data){
        if(!this.events[event]||this.events[event].length===0) return;
        this.events[event].forEach(cb=>cb(data))
    }
    unsubscribe(event,callback){
        if(!this.events[event]) return;
        this.events[event]=this.events[event].filter(cb=>cb!==callback)
    }
}

const pubsub=new PubSub()

const unsubscribeHello=pubsub.subscibe('hello',msg=>{
    console.log('received',msg)
})
pubsub.publish('hello','zzzzwwwkkk')
unsubscribeHello()
```


发布订阅模式是一种消息传递模式，其中发送者(发布者)不会直接将消息发送给特定的接收者(订阅者)，而是发布到称为"主题"或"事件"的抽象类别中，感兴趣的订阅者可以订阅这些主题。


在代码中：

- **`PubSub`** 类作为事件总线或调度中心
- **`subscribe`** 方法允许订阅者注册对特定事件的兴趣
- **`publish`** 方法允许发布者触发事件并通知所有订阅者
- **`unsubscribe`** 方法允许取消订阅

### **与普通函数调用的区别**

1. **解耦性**：
    - 发布订阅模式：发布者和订阅者完全解耦，发布者不需要知道谁在订阅
    - 普通调用：调用方需要明确知道被调用方的引用
2. **一对多通信**：
    - 发布订阅模式：一个发布者可以同时通知多个订阅者
    - 普通调用：通常是一对一的直接调用
3. **动态性**：
    - 发布订阅模式：订阅者可以在运行时动态地订阅或取消订阅
    - 普通调用：调用关系在代码中静态定义
4. **扩展性**：
    - 发布订阅模式：可以轻松添加新的订阅者而不需要修改发布者代码
    - 普通调用：添加新的接收者可能需要修改调用方代码
5. **灵活性**：
    - 发布订阅模式：可以基于事件类型进行选择性通知
    - 普通调用：需要明确调用特定函数

## **示例对比**


**发布订阅模式**（如你的代码）：


```javascript
// 多个订阅者可以独立订阅同一事件
pubsub.subscribe('hello', msg => console.log('订阅者1:', msg));
pubsub.subscribe('hello', msg => console.log('订阅者2:', msg));

// 发布者不需要知道谁在订阅
pubsub.publish('hello', '消息内容');
```


**普通函数调用**：


```javascript
// 调用方需要明确知道被调用方
function subscriber1(msg) {
  console.log('订阅者1:', msg);
}

function subscriber2(msg) {
  console.log('订阅者2:', msg);
}

// 调用方需要显式调用每个订阅者
subscriber1('消息内容');
subscriber2('消息内容');
```


### 防抖


```typescript
function debounce(fn,delay){
    let timer=null;
    return function(...args){
        const context=this;
        if(timer){
            clearTimeout(timer)
        }
        setTimeout(() => {
            fn.apply(context,args)
        }, delay);
    }
}
```


主要几个模块，定时器,this,和回调


**其中this一直很难懂 但是我发现有点懂了**


```typescript
const input = document.querySelector('input');

input.addEventListener('input', debounce(function() {
  console.log(this);        // 我们希望这里是 input 这个 DOM 元素
  console.log(this.value);  // 希望能直接拿到输入框的值
}, 300));
//其中本来的监听回调现在是有两层函数一层debounce一层定时函数里的函数
```


普通函数this是运行时候确认的，这里有个标准不带防抖版


```typescript
document.querySelector("button").addEventListener("click", function () {
        console.log(this); //正常输出元素
});
```


但是防抖现在是相当于**回调的上一层（是正常时候的唯一函数层）**这时候是有正确this的 回调是没有的 所以必须存储一下 我们真正执行的函数层被防抖包裹了一层实际上是里层获取不到外层本来能得到的this了


## 扁平化数组


```typescript
let arr = [[23, 32321], [2313], 23];
const flatten = (arr) => {
  return arr.reduce((prev, curr) => {
    const next = Array.isArray(curr) ? flatten(curr) : curr;
    return prev.concat(next);
  }, []);
};
console.log(flatten(arr));
//output:[ 23, 32321, 2313, 23 ]
```


## 深拷贝


```typescript
// map 用来记录已经拷贝过的对象，防止死循环（比如 A 里面引用了 A）。
function deepClone(obj, map = new WeakMap()) {
  
  // 1. 基础类型出口。
  // 如果是 null 或者不是对象（是数字、字符串），不用拷贝，直接返回。
  if (obj === null || typeof obj !== 'object') return obj;
  
  // 2. 查表（防循环引用）。
  // 看看 map 记录本里，这个 obj 是不是之前已经拷贝过了？
  // 如果拷贝过，直接把上次拷贝的结果拿出来，不要再递归了。
  if (map.has(obj)) return map.get(obj);
  
  // 3. 创建新容器。
  // 如果 obj 是数组，就 new Array()，是对象就 new Object()。
  // obj.constructor 就能自动找到它是数组还是对象。
  const newObj = new obj.constructor();
  
  // 4. 记录备案。
  // 把原对象(obj)和新对象(newObj)的关系记下来，防止下次再遇到死循环。
  map.set(obj, newObj);
  
  // 5. 遍历属性。
  // 把 obj 里的每一个 key 都拿出来。
  for (const key in obj) {
    // 只拷贝对象自己的属性，不拷贝原型链上的。
    if (obj.hasOwnProperty(key)) {
      // 6. 递归关键！
      // 属性的值 (obj[key]) 可能还是个对象，所以要再次调用 deepClone。
      // 把结果赋值给新对象。
      newObj[key] = deepClone(obj[key], map);
    }
  }
  
  return newObj;
}
```


## 虚拟滚动


```css
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>虚拟列表 - 修正版</title>
  <style>
    body { margin: 0; padding: 20px; font-family: sans-serif; }
    
    #container {
      height: 300px; /* 设置固定高度 */
      overflow-y: auto;
      position: relative;
      border: 1px solid #ccc;
    }

    #phantom {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      z-index: -1; /* 确保在底层 */
      /* height 将由 JS 动态设置 */
    }

    #visible {
      position: absolute;
      left: 0;
      right: 0;
      top: 0; /* 修正：必须显式指定 top: 0 */
    }

    /* 修正：增加 box-sizing 确保高度包含边框 */
    .list-item {
      height: 30px;
      border-bottom: 1px solid #eee;
      padding-left: 8px;
      box-sizing: border-box; /* 关键：让高度包含边框，实际高度就是 30px */
      line-height: 30px; /* 让文字垂直居中 */
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="phantom"></div> 
    <div id="visible"></div> 
  </div>

  <script>
    const container = document.getElementById('container');
    const phantom = document.getElementById('phantom');
    const visible = document.getElementById('visible');

    const itemHeight = 30; 
    const total = 1000000;   
    const data = Array.from({ length: total }, (_, i) => `Item ${i + 1}`);

    // 设置占位高度
    phantom.style.height = `${total * itemHeight}px`;

    function getVisibleCount() {
      // 每次渲染时重新计算，防止容器大小变化或初始化时获取不到高度
      return Math.ceil(container.clientHeight / itemHeight);
    }

    function render(startIndex) {
      const visibleCount = getVisibleCount();
      
      // 安全检查：如果高度获取失败（如初始加载时），强行渲染一定数量防止空白
      const safeVisibleCount = visibleCount > 0 ? visibleCount : 10;

      // 计算结束索引
      const endIndex = startIndex + safeVisibleCount;

      // 取出可视区域数据
      const visibleData = data.slice(startIndex, endIndex);

      // 生成 HTML
      visible.innerHTML = visibleData.map(item =>
        `<div class="list-item">${item}</div>` 
      ).join('');

      // 设置偏移量
      visible.style.transform = `translateY(${startIndex * itemHeight}px)`;
    }

    // 初始化：使用 requestAnimationFrame 确保 DOM 布局已完成，clientHeight 有值
    requestAnimationFrame(() => {
      render(0);
    });

    // 监听滚动
    container.addEventListener('scroll', () => {
      // 节流：如果不需要极度复杂的节流，可以直接计算
      const start = Math.floor(container.scrollTop / itemHeight);
      render(start);
    });
    
    // 可选：监听窗口大小变化，重新计算 visibleCount
    window.addEventListener('resize', () => {
       // 简单的重置渲染当前索引即可
       const start = Math.floor(container.scrollTop / itemHeight);
       render(start);
    });

  </script>
</body>
</html>
```


原理：


**制造高度幻觉**


**问题**：如果我只渲染 10 条数据，容器高度只有 300px，根本就没有滚动条，用户怎么往下滚？


**原理**：我们需要一个“替身”来撑开容器的高度。


在你的代码中，**`#phantom`** 这个 **`div`** 就是这个替身。
它的作用是：

1. 设置为绝对定位，不占据文档流空间（看不见）。
2. 把它的高度设置为 **`总条数 × 每条高度`**（例如：10000条 × 30px = 300,000px）。

**效果**：浏览器会以为这个页面非常长，于是显示出了长长的滚动条。


**计算视窗位置**


**问题**：我现在有了滚动条，用户滚到了第 5000 条的位置。但我只渲染了 10 条 DOM 节点，我该渲染哪 10 条呢？


**原理**：监听滚动事件，用数学公式算出当前视口（眼睛看到的范围）对应数据的哪一部分。


**位移蒙版**


**问题**：我已经把第 500 到 510 条数据渲染出来了，默认它们会出现在容器的最顶部（top: 0）。但实际上用户滚到了很下面，这 10 条数据应该出现在中间偏下的位置才对啊！


**原理**：给渲染出来的这几条数据一个“向下推”的力（使用 **`transform: translateY`**）。


公式逻辑：

- **偏移量** = **`startIndex × itemHeight`**
- 如果是第 500 条开始，偏移量就是 500 × 30 = 15,000px。
