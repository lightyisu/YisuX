---
catalog:
  - jishu
date: '2025-12-10 08:00:00'
type: Post
slug: mianshi2
title: 面试 | 前端问题Ai未来型
status: 已发布
urlname: 2c5e9dc9-c245-8031-874a-e60b6a70ae7a
updated: '2026-01-11 15:02:00'
---

## 前端工程师未来会被ai取代吗


GPT帮整理：


前端工程师不会被 AI 取代，但「大量低价值前端」一定会消失。


### 做懂「工程」的前端


AI 很会写代码，但**极弱于工程决策**：

- 项目结构怎么拆？
- 状态放哪里？Redux / Zustand / URL / Server？
- 组件怎么设计才能复用 3 年？
- 怎么避免后期技术债爆炸？

技术债不是因为代码写得不优雅，而是因为「变化没有被显式建模」


你以为不会变的东西，最后一定会变。

1. 把稳定的东西写成灵活 把一定会变的东西写死
2. 隐式约定太多
3. 抽象提前 or 抽象错误 用一个组件 cover 10 种场景

解决方法：

1. **用「变化轴」而不是「功能」拆模块** 其实就是哪些容易变动放到一块去不容易变动的放一起
2. **把「不稳定的东西」显式包一层**  立刻包一层，不要直连。
3. **宁愿“重复一点”，也不要“错误抽象”** 其实是组件复用性的坏处 因为复用多处等于改多处
4. **状态来源不清晰**
5. **每个模块必须有「逃生通道」** 会被替换的可能性

### 懂「业务 & 产品」的前端

- 这个交互是不是用户真的需要？
- 这个 loading 会不会让用户焦虑？
- 为什么这里要“慢一点反而更好”？

### 高级前端 / 前端架构师

- 微前端 / Monorepo
- SSR / RSC / Edge
- 性能优化（LCP、CLS、INP）
- 跨端（Web + RN + Electron + 小程序）
- 可视化 / 编辑器 / 图形系统

## 前端一些新技术


### **React Server Component**


React Server Component（简称 RSC）是一种新型 React 组件，它专为在服务器端渲染而设计，与传统的客户端组件不同，RSC 的代码不会被打包发送到浏览器，而是直接在服务器上执行并生成 HTML 发送给客户端。这使得它能够直接访问服务器资源（如数据库），从而减少客户端 JavaScript 捆绑包的大小，提高应用性能和加载速度。


RSC 是 React 生态中一项重大范式转变，它将组件分为两类：**服务器组件**（默认）和**客户端组件**（需用 'use client' 标记）。服务器组件在服务器上一次性渲染，不参与客户端的水合（hydration）过程，因此它们更轻量且高效，适合处理静态内容或数据密集型逻辑。


**主要优势**：

- **性能优化**：零客户端 JS 开销，减少捆绑包大小（可达 90% 以上减少）。
- **数据获取**：直接在组件中调用服务器 API，无需额外网络请求。请求后直接包裹在html模板。
- **安全性**：敏感逻辑（如 API 密钥）保持在服务器端。

### **“信号式”响应式**


与传统的虚拟 DOM（Virtual DOM）模型不同，信号式响应式不依赖运行时 diffing（差异比较），而是直接追踪数据依赖关系，只在真正变化的部分触发 DOM 更新


为什么更精细、高性能？
信号追踪依赖图变化传播如涟漪，只波及下游节点。相比虚拟 DOM 的“树遍历”，这减少 90%+ 的无谓计算。在 JS Framework Benchmark（2025 数据），Solid.js/Qwik/Svelte 5 的运行时速度是 React 的 2-3 倍，内存使用低 50%。


虚拟dom→信号式


在 2010 年代初，前端开发面临一个核心痛点：真实 DOM 操作昂贵且低效。浏览器中的真实 DOM（Document Object Model）是一个树状结构，每次修改（如添加/删除元素、更改属性）都会触发重绘（reflow）和重排（repaint），这在复杂、动态 UI（如 Facebook 的新闻 feed）中会导致性能瓶颈——频繁更新可能让页面卡顿，甚至崩溃。


**总结：更改一次就会回流一次太卡了 直接用虚拟dom算完了一次回流**


信号式不会面对真实 DOM 操作昂贵且低效？

- **原生DOM操作 (jQuery时代)**：**一个拿着大锤的工人**。你想把墙上的一颗钉子敲进去一点，他抡起大锤，“哐”地一下砸在墙上。虽然钉子动了，但整面墙都在震。如果你让他敲100下，墙可能就塌了（页面卡顿）。这个过程是**手动、粗暴、且容易误伤**的。
- **虚拟DOM (React/Vue)**：**一个聪明的建筑师团队**。每次你想修改房子，他们不会直接动工。而是先在图纸上画一个新设计（新VDOM树），然后和旧图纸对比，找出所有需要修改的地方。最后，工头会拿着一份清单，指挥工人一次性、高效地把所有改动做完。这个过程是**批量、优化过的**，但每次都需要“重新画图纸”和“对比图纸”的成本。
- **信号式响应式**：**一个拥有精密传感器的智能家居系统**。系统里每个设备（UI节点）都知道自己依赖于哪个传感器（信号）。比如，客厅的灯（**`<p>`**标签）只连接到“亮度传感器”（**`count`**信号）。当“亮度传感器”的数值变化时，系统**只**会向客厅的灯发送指令，让它调整亮度。其他房间的设备（空调、电视）完全不受影响。这个过程是**自动、精准、且影响范围最小**的。

**核心秘诀：高细粒度/隐式的订阅关系**


**1. 细粒度订阅**


```javascript
// Solid.js 示例
const count = signal(0);

// 在JSX中读取信号
function Counter() {
  return (
    <div>
      <p>Count: {count()}</p>  // <p> 标签订阅了 count 信号
      <button onClick={() => count.value++}>Increment</button>
    </div>
  );
}
```


框架在初次渲染时，会建立一个**隐式的订阅关系**：**`<p>`** 这个DOM节点里的文本内容，订阅了 **`count`** 这个信号。这个关系是**精确到DOM节点级别**的，而不是组件级别。



**2.直接、最小化更新**


当你点击按钮，**`count.value`** 变化时，会发生什么？

- **没有组件重新渲染**：**`Counter`** 函数**不会**被重新执行。
- **没有VDOM Diff**：框架**不会**创建新的虚拟DOM树来进行比较。
- **直接更新**：**`count`** 信号会通知所有订阅了它的地方。在这个例子里，它只会通知那个 **`<p>`** 标签。然后框架会执行一个**极其轻量级**的操作，类似于 **`p.textContent = "Count: 1"`**。

这个操作的开销，远小于“重新执行组件函数 + Diff算法 + 批量Patch”的总和。


**3. 批量更新**


优秀的信号式框架（如Solid.js）会处理这个问题。它会将同一个微任务队列中的所有DOM更新**收集起来，然后一次性、按顺序地应用到真实DOM上**。这避免了“布局抖动”，确保了性能，和虚拟DOM的批量更新有异曲同工之妙，但它的决策依据是“哪些信号变了”，而不是“新旧VDOM树哪里不同”。
核心：对比订阅列表


| 特性        | 原生DOM操作 (jQuery)                       | 虚拟DOM                               | 信号式响应式                          |
| --------- | -------------------------------------- | ----------------------------------- | ------------------------------- |
| **更新范围**  | **开发者手动决定**，容易过大，引发不必要的Reflow/Repaint。 | **组件级别**。一个状态变化可能导致整个组件树被重新渲染和Diff。 | **DOM节点级别**。只更新真正依赖该数据的DOM部分。   |
| **决策开销**  | **无**，直接操作，但决策本身容易出错。                  | **高**。每次更新都需要重新执行组件函数和运行Diff算法。     | **极低**。信号变化时，直接通过订阅关系找到目标，无需计算。 |
| **DOM操作** | **频繁、零散、不可预测**。                        | **批量、优化后**。但可能更新了并未改变的部分。           | **最小化、精准、批量**。理论上只更新绝对必要的部分。    |
| **心智模型**  | 命令式："我命令你改变这个元素"。                      | 声明式："UI是状态的函数，状态变了UI就变"。            | 声明式："这个UI依赖这个数据，数据变了UI自动变"。     |

