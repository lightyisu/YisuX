---
catalog:
  - jishu
date: '2026-01-28 08:00:00'
type: Post
slug: fdwadwa
title: 技术点回顾
status: Draft
urlname: 2f6e9dc9-c245-8060-9e3d-c26729162904
updated: '2026-02-28 00:59:00'
---

还是得记一下不然每次提问其实我不准备很难把逻辑理的太清楚。


## 专业提问


我本科是数字媒体技术，其实从本科开始就一直在做前端相关的事情，包括课程设计、项目和后面的实习。硕士选择人工智能，主要是出于两个原因：
一方面是希望系统性地补强自己的**计算机基础和建模能力**，另一方面我对**复杂系统、数据和性能问题**本身比较感兴趣。从长期来看，我更希望成为一个工程能力很强、同时理解底层原理的前端工程师，而不是纯研究方向。因为学校里也不可能开设前端底层研究的学位所以从人工智能的角度入手不仅能够拓宽视野也能够拉开自己的技术纵深。并且在未来自己会尝试前端和AI结合的项目或者对前端的底层进行一个纵向的学习。在使用 AI 工具（比如 Claude Code）时，我会更清楚它的能力边界，以及更理解AI工具对前端工程的可扩展可探索的地方。而且很多前端技术文章都在探索AI在前端的最佳实践，我觉得这个学习对我来说是有帮助的。


**「那你为什么不直接做 AI / 算法？」**


我尝试过，也做过比较深入的研究，但我个人感受到的差异是：算法和研究的正反馈周期相对较长，而前端工程中，我可以更快地看到自己的工作被用户直接使用，这种反馈会让我更有动力持续投入。


**「那你以后会不会又转回 AI？」**


我现在非常清楚自己希望在工程能力上继续深挖，而前端的深度和复杂度本身也完全足够支撑长期发展。


**「那你读研这段经历对前端有什么实际帮助？」**


第一是对复杂问题的拆解能力,我会习惯先厘清思路，再落代码；
第二是对性能和系统稳定性的敏感度，这在前端工程中其实非常重要；
第三是让我在使用 AI 工具（比如 Claude Code）时，更清楚它的能力边界，不会盲目依赖。探索AI在前端的最佳实践，我觉得这个学习对我来说是有帮助的。


## webpack


webpack我已经很久没碰了 因为vite的原因 面试官可能会问随便讲一下


「Webpack」Webpack 本质上是一个静态模块打包器。它从入口文件出发，递归解析依赖图谱，将项目中的 JS、CSS、图片等资源均视为模块，最终打包成浏览器可运行的静态资源。


「Webpack Loader」负责模块转换，将非 JavaScript 文件（如 SCSS、TypeScript、图片）转换为有效模块。


 「Webpack Plugin」基于 Tapable 插件系统，介入构建的**整个生命周期**，执行代码压缩、资源优化、HTML 生成等更广泛的任务。


「与Vite」Webpack 在开发模式下，需要 **先分析依赖图谱并完成全量打包**（通常在内存中），才能启动服务响应请求，因此随着项目规模增大，冷启动会变慢。而 Vite 利用浏览器原生 **ES Module** 能力，开发阶段对业务代码 **按需编译和加载**，同时使用 **esbuild** 预构建依赖，因此冷启动和热更新（HMR）速度极快，且与项目规模无关。在生产构建阶段，Vite 底层默认使用 **Rollup** 进行打包，这与 Webpack 的目标一致，都是为了 **代码压缩、Tree-shaking 和输出优化的静态资源**。


## 原子化工具TailwindCSS


**「本质」**


Tailwind CSS 采用 **Utility-First（功能优先）** 理念，提供了一套预定义的、**低层级（Low-level）的工具类**。它将样式拆解为细粒度的单一职责单元（如 `flex`、`p-4`），直接在 HTML 中**组合这些工具类**来构建界面。这种方式**避免了传统 CSS 中为组件发明新类名和维护样式表的开销**，同时保证了设计的一致性。


**「构建优势」**

1. 运行 `npm run build` 时，Tailwind 的编译器会像“阅读器”一样，遍历你项目中的所有代码文件。它会提取出写过的 Tailwind 类名
2. 提取出类名后，它会对照 `tailwind.config.js` 配置文件。转换成真实的 CSS 。

**「JIT」**


JIT带来最明显的应该是开发环境感知（因为v2和v3最终输出都有裁剪），我觉得很像是Nodejs在旁路做了一层CSS in js，用Nodejs 动态计算样式再贴上浏览器。真CSS in js是用浏览器的runtime 跑的。最后JIT使得可以自己生成一个不固定的动态样式了比如 `w-[100px]` 这种 v2 需要自己写一遍CSS 样式但是 JIT 可以自己生成。


**「缺点」**

1. HTML 标签中会充斥着大量的 class 名，导致代码可读性下降，结构不清晰。（重复样式提取为组件可缓解）
2. 耦合了结构与表现，导致修改样式必须修改 HTML 文件。
3. 全局修改困难，在传统 CSS 中只需修改 `.btn-primary` 一处，而在 Tailwind 中，需要全局搜索所有使用了 `bg-blue-500` 。
4. JIT 限制， JIT 编译器是通过静态扫描代码来生成 CSS 的。如果你动态拼接类名，编译器无法识别，做不到CSS in js的效果。`const className = bg-${color}-500;`

## CSS in Js 以及 CSS 模块化


**「CSS in Js 」**


最早接触到这个是因为React的学习，因为React没有Vue那种scoped的方案最流行的是css in js。第一个接触到的实现这样设计的库是`styled-components` 。


「CSS in Js  概念」将样式代码直接写在组件的 JavaScript


「CSS in Js  优势」

1. 解决命名冲突，生成唯一的类名样式隔离。
2. 独家优势，动态样式容易切换。
3. 维护性高，高内聚，样式和组件在一起方便维护。

「CSS in Js  缺点」

1. 有自己的运行时 开销大 影响速度
2. 不好调试

「CSS in Js  场景」

1. 高度动态的组件库开发
2. 强大的主题系统

「CSS in Js  经典库」

1. styled-components: 鼻祖级库 。
2. Emotion: 性能比 styled-components 稍好,国内看很多react前端用这个。
3. 零运行时库**：**说白了就是不在浏览器计算样式了，打包的时候node算好贴上去。想想这个其实不就是tailwindcss的jit模式吗。不过外壳不同，很明显与台风css写法不一样。

**「CSS 模块化」**


「原理」基于构建工具的特性（通常由 Webpack、Vite 等打包工具提供）。


「用法」通常将样式文件命名为 `xxx.module.css` 在打包编译时，构建工具会扫描这些文件给类名加hash。用的时候用import导入`import styles from './Button.module.css';` 加对象用法拿样式`<button className={styles.btn}>点击</button>` 。一种介于原生和CSS in Js中间态的工具。


「优势」

1. 是个CSS工具都有的隔离。
2. 用法简单

「劣势」

1. 隔离不完全 变量隔离不了

## 架构设计之内聚与耦合


高内聚，低耦合是好的设计。


「**内聚**」内聚衡量的是**一个模块内部**各个元素（函数、类、样式、逻辑）彼此结合的紧密程度

- **高内聚（好）：** 一个模块只专注做**一件事**，且把所有相关的东西都放在一起。
- **低内聚（坏）：** 一个模块什么都做，功能杂乱，相关的代码分散在各处。

**「例子」**

- **高内聚：** 一个 `User` 类，只负责处理用户数据（名字、邮箱、验证）。
- **低内聚：** 一个 `Utils` 类，里面既有用户验证，又有数据库连接，还有日期格式化，甚至还有 UI 颜色定义。
- **CSS-in-JS / CSS Modules：** 把按钮的 **HTML 结构**、**点击逻辑**、**外观样式** 都放在同一个组件文件里。这是**高内聚**。因为样式是组件表现的一部分，它们本该在一起。删组件时一起删，改组件时一起改。

**「耦合」**耦合衡量的是**不同模块之间**相互依赖的程度

- **低耦合（好）：** 模块 A 和模块 B 独立工作。A 变了，B 不受影响。
- **高耦合（坏）：** 模块 A 强依赖模块 B 的内部细节。A 一变，B 就崩。（类似积木效应）

**「例子」**

- **低耦合：** 函数 A 调用函数 B，只传递参数，不关心 B 内部怎么实现。
- **高耦合：** 函数 A 直接修改了函数 B 内部的全局变量，或者 A 的代码里写死了 B 的类名。

**「总结」**


内聚（Cohesion）看内部： 关注“这个模块是否专注”。耦合（Coupling）看外部： 关注“模块之间是否独立”。


## 咪鼠#1


### 1.Web Audio API


和`<audio>`浏览器给你的成品播放器不同 `Web Audio API`是自定义的音频流水线 相当于Web的音频工具包

- 音频是“数据流”
- 有独立的 **AudioContext 时间轴**
- 可以接：解码、处理、分析、输出
- **时间稳定、精度高**
- 硬件时钟

性能优化：


`audio.currentTime` 依赖浏览器渲染，页面卡顿、tab 切后台会飘 所以不用


`audioContext.currentTime`和渲染线程解耦 更稳定、更适合做同步


缺点就是需要自己写一点界面逻辑，手动维护一些时间逻辑


**精度和性能是核心诉求不得不用** 


因为既要在会议系统里的**字幕做一些滚动，标记，删除，以及批量管理的操作(DOM操作+JS计算）**，主线程的业务代码很多，如果用HTML5 Audio会导致时钟的小偏移同时也可能造成一些字幕的偏移这在业务中是不能出现的。因为会议记录往往是连续的句话，时间戳很紧凑。需要精准的时间戳。
参考了 **Google Meet** 和 **剪映** 处理音频流的思路，选择用 **Web Audio API** 的硬件时钟来驱动 UI
我的时钟是基于硬件音频采样率的，不论主线程写了多少业务代码，时钟永远不会飘移。这保证了 2 小时会议记录的字幕同步精度始终在帧级以内


### 2.字幕滚动匹配算法


使用requestAnimationFrame 里更新 UI


**索引预计算（滚动）：**


在加载页面后扫描收到的字幕数据，会根据时间顺序进行字幕的索引，将音频时间和字幕时间戳匹配提取出通过索引切分成对应的字幕分块的一个映射表，通过维护这个映射表做到拖动时自动快速匹配字幕。


**虚拟列表字幕展示：**


在字幕条数比较多的情况下，如果一次 性渲染所有字幕节点，会有不必要的 DOM 开销，所以我在展示层做了类似**虚拟列表的处理**，只渲染当前可视窗口附近的字幕项，其余的通过占位高度来保持滚动位置。


**拖动同步：**


在拖动音频轴的时候要做到实时的同步拖动字幕滚动，字幕滚动始终绑定当前时间轴状态，在拖动过程中实时派生渲染对应字幕。并且通过之前预计算的索引直接返回合适的字幕区域。


### 咪鼠#2


### 1.多组件状态不一致


在这个音频模块里，播放状态、当前时间、拖动状态会被多个组件同时依赖，如果各组件各自维护或通过 props 传递，很容易出现状态不同步，导致重复渲染和短暂的 UI 卡顿。在全局状态中我只保留音频播放和时间轴这些必须共享的核心状态，像进度百分比、当前字幕索引这类 UI 派生状态，我放在组件内部通过计算得到，避免不必要的全局依赖和重复渲染。


把计算状态不写进VueX中，只写进核心状态降低全局依赖面。降低渲染成本。


## 讯飞


## Hexo插件


PPT/DOCX
**介绍：**我是通过 Hexo 提供的 标签插件机制，注册了一个自定义的 `ppt` 标签。
在构建阶段，当 Hexo 解析 Markdown 时遇到 `{% ppt xxx.pptx %}` 这样的标签，我会返回一段已经拼装好的 HTML，用来在最终页面中直接渲染 PPT 预览。


**原理：**插件内部并没有自己去解析 PPT 文件，而是复用了一个现成的前端库。在构建阶段我会通过 Node.js 读取该库所需的 JS 和 CSS 资源，然后在生成的 HTML 中以内联的方式注入这些资源，并初始化对应的渲染逻辑。
**使用：**在 Markdown 中只需要通过一个自定义标签声明 PPT 地址，比如 `{% ppt url %}`，插件会在构建时把这个标签替换成对应的 HTML 预览结构。


总结：这是一个基于 Hexo 构建生命周期的内容扩展插件，通过模板注入实现文档预览，并没有涉及复杂的文件解析逻辑。


## 数字人ws直播


这个项目本身是一个偏应用层的 Demo，我主要负责的是 Web 端对 WebRTC 流的接入、播放以及基础交互ws，并没有涉及底层协议或服务端实现。


在这个 Demo 里：

1. WebSocket 负责交换 offer / answer（不传视频）
2. RTCPeerConnection 负责建立媒体连接
3. 视频流通过 ontrack 进 video 标签

WebSocket作为WebRTC的信令传输通道


## 网盘


对于大文件上传，前端会将文件按固定大小进行切片，通过标识文件唯一性的 hash 或 id，将切片逐个上传给后端，由后端负责合并和校验。这样可以降低单次上传失败的成本，也方便后续做断点续传。


实现：



1️⃣用 `File.slice` 切文件


设置切片大小 引入sparkmd5获取整个文件的hash值 把所有数据包裹在formData 上传完切片请求合并此时通知上传成功


**切片上传使用 FormData，是因为它最适合承载二进制文件数据，同时还能方便地携带分片相关的元信息。**
2️⃣ 每个切片带上必要信息


```javascript
{
  fileId,      // 文件唯一标识
  chunkIndex,  // 当前第几块
  totalChunks  // 总块数
  filehash //文件标识
}
```


断点续传：原理再上传没传完的块


秒传：上传文件时，先提交文件的哈希值


优化切片多的问题：1限制同时上传的分片数量使用“动态任务池”Promise.race() 2切片大小动态调整 3使用 Web Worker





在项目中对 Axios 做了一层统一封装，主要包括请求和响应拦截、统一的错误处理、以及 token 的自动携带，减少业务代码中重复逻辑。拦截器更多是用来约束请求行为和统一处理副作用，而不是承载认证本身。


登录态主要通过 cookie 保存 token，在请求时由 Axios 拦截器自动携带，前端根据接口返回状态判断是否需要重新登录。


在表单输入和搜索等高频操作中使用防抖，减少无意义请求，同时对未提交的表单内容做本地缓存，提升用户体验。

