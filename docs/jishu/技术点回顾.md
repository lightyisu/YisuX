---
catalog:
  - jishu
date: '2026-01-28 08:00:00'
type: Post
slug: fdwadwa
title: 技术点回顾
status: Draft
urlname: 2f6e9dc9-c245-8060-9e3d-c26729162904
updated: '2026-02-28 18:22:00'
---

还是得记一下不然每次提问其实我不准备很难把逻辑理的太清楚。


## 专业提问


我本科是数字媒体技术，其实从本科开始就一直在做前端相关的事情，包括课程设计、项目和后面的实习。硕士选择人工智能，主要是出于两个原因：
一方面是希望系统性地补强自己的**计算机基础和建模能力**，另一方面我对**复杂系统、数据和性能问题**本身比较感兴趣。从长期来看，我更希望成为一个工程能力很强、同时理解底层原理的前端工程师，而不是纯研究方向。因为学校里也不可能开设前端底层研究的学位所以从人工智能的角度入手不仅能够拓宽视野也能够拉开自己的技术纵深。并且在未来自己会尝试前端和AI结合的项目或者对前端的底层进行一个纵向的学习。在使用 AI 工具（比如 Claude Code）时，我会更清楚它的能力边界，以及更理解AI工具对前端工程的可扩展可探索的地方。而且很多前端技术文章都在探索AI在前端的最佳实践，我觉得这个学习对我来说是有帮助的。


**「那你为什么不直接做 AI / 算法？」**


我尝试过，也做过比较深入的研究，但我个人感受到的差异是：算法和研究的正反馈周期相对较长，而前端工程中，我可以更快地看到自己的工作被用户直接使用，这种反馈会让我更有动力持续投入。


**「那你以后会不会又转回 AI？」**


我现在非常清楚自己希望在工程能力上继续深挖，而前端的深度和复杂度本身也完全足够支撑长期发展。


**「那你读研这段经历对前端有什么实际帮助？」**


第一是对复杂问题的拆解能力,我会习惯先厘清思路，再落代码；
第二是对性能和系统稳定性的敏感度，这在前端工程中其实非常重要；
第三是让我在使用 AI 工具（比如 Claude Code）时，更清楚它的能力边界，不会盲目依赖。探索AI在前端的最佳实践，我觉得这个学习对我来说是有帮助的。


## webpack


webpack我已经很久没碰了 因为vite的原因 面试官可能会问随便讲一下


「**Webpack**」Webpack 本质上是一个静态模块打包器。它从入口文件出发，递归解析依赖图谱，将项目中的 JS、CSS、图片等资源均视为模块，最终打包成浏览器可运行的静态资源。


「**Webpack Loader**」负责模块转换，将非 JavaScript 文件（如 SCSS、TypeScript、图片）转换为有效模块。


 「**Webpack Plugin**」基于 Tapable 插件系统，介入构建的**整个生命周期**，执行代码压缩、资源优化、HTML 生成等更广泛的任务。


「**与Vite**」Webpack 在开发模式下，需要 **先分析依赖图谱并完成全量打包**（通常在内存中），才能启动服务响应请求，因此随着项目规模增大，冷启动会变慢。而 Vite 利用浏览器原生 **ES Module** 能力，开发阶段对业务代码 **按需编译和加载**，同时使用 **esbuild** 预构建依赖，因此冷启动和热更新（HMR）速度极快，且与项目规模无关。在生产构建阶段，Vite 底层默认使用 **Rollup** 进行打包，这与 Webpack 的目标一致，都是为了 **代码压缩、Tree-shaking 和输出优化的静态资源**。


## 原子化工具TailwindCSS


**「本质」**


Tailwind CSS 采用 **Utility-First（功能优先）** 理念，提供了一套预定义的、**低层级（Low-level）的工具类**。它将样式拆解为细粒度的单一职责单元（如 `flex`、`p-4`），直接在 HTML 中**组合这些工具类**来构建界面。这种方式**避免了传统 CSS 中为组件发明新类名和维护样式表的开销**，同时保证了设计的一致性。


**「构建优势」**

1. 运行 `npm run build` 时，Tailwind 的编译器会像“阅读器”一样，遍历你项目中的所有代码文件。它会提取出写过的 Tailwind 类名
2. 提取出类名后，它会对照 `tailwind.config.js` 配置文件。转换成真实的 CSS 。

**「JIT」**


JIT带来最明显的应该是开发环境感知（因为v2和v3最终输出都有裁剪），我觉得很像是Nodejs在旁路做了一层CSS in js，用Nodejs 动态计算样式再贴上浏览器。真CSS in js是用浏览器的runtime 跑的。最后JIT使得可以自己生成一个不固定的动态样式了比如 `w-[100px]` 这种 v2 需要自己写一遍CSS 样式但是 JIT 可以自己生成。


**「缺点」**

1. HTML 标签中会充斥着大量的 class 名，导致代码可读性下降，结构不清晰。（重复样式提取为组件可缓解）
2. 耦合了结构与表现，导致修改样式必须修改 HTML 文件。
3. 全局修改困难，在传统 CSS 中只需修改 `.btn-primary` 一处，而在 Tailwind 中，需要全局搜索所有使用了 `bg-blue-500` 。
4. JIT 限制， JIT 编译器是通过静态扫描代码来生成 CSS 的。如果你动态拼接类名，编译器无法识别，做不到CSS in js的效果。`const className = bg-${color}-500;`

## CSS in Js 以及 CSS 模块化


**「CSS in Js 」**


最早接触到这个是因为React的学习，因为React没有Vue那种scoped的方案最流行的是css in js。第一个接触到的实现这样设计的库是`styled-components` 。


「**CSS in Js  概念**」将样式代码直接写在组件的 JavaScript


「**CSS in Js  优势**」

1. 解决命名冲突，生成唯一的类名样式隔离。
2. 独家优势，动态样式容易切换。
3. 维护性高，高内聚，样式和组件在一起方便维护。

「**CSS in Js  缺点**」

1. 有自己的运行时 开销大 影响速度
2. 不好调试

「**CSS in Js  场景**」

1. 高度动态的组件库开发
2. 强大的主题系统

「**CSS in Js  经典库**」

1. styled-components: 鼻祖级库 。
2. Emotion: 性能比 styled-components 稍好,国内看很多react前端用这个。
3. 零运行时库：就是不在浏览器计算样式了，打包的时候node算好贴上去。想想这个其实不就是tailwindcss的jit模式吗。

**「CSS 模块化」**


「**原理**」基于构建工具的特性（通常由 Webpack、Vite 等打包工具提供）。


「**用法**」通常将样式文件命名为 `xxx.module.css` 在打包编译时，构建工具会扫描这些文件给类名加hash。用的时候用import导入`import styles from './Button.module.css';` 加对象用法拿样式`<button className={styles.btn}>点击</button>` 。一种介于原生和 CSS in Js 中间态的工具。


「**优势**」

1. 是个CSS工具都有的样式隔离
2. 用法简单

「**劣势**」

1. 隔离不完全 变量隔离不了

## 架构设计之内聚与耦合


高内聚，低耦合是好的设计。


「**内聚**」内聚衡量的是**一个模块内部**各个元素（函数、类、样式、逻辑）彼此结合的紧密程度

- **高内聚（好）：** 一个模块只专注做**一件事**，且把所有相关的东西都放在一起。
- **低内聚（坏）：** 一个模块什么都做，功能杂乱，相关的代码分散在各处。

**「例子」**

- **高内聚：** 一个 `User` 类，只负责处理用户数据（名字、邮箱、验证）。
- **低内聚：** 一个 `Utils` 类，里面既有用户验证，又有数据库连接，还有日期格式化，甚至还有 UI 颜色定义。
- **CSS-in-JS / CSS Modules：** 把按钮的 **HTML 结构**、**点击逻辑**、**外观样式** 都放在同一个组件文件里。这是**高内聚**。因为样式是组件表现的一部分，它们本该在一起。删组件时一起删，改组件时一起改。

**「耦合」**耦合衡量的是**不同模块之间**相互依赖的程度

- **低耦合（好）：** 模块 A 和模块 B 独立工作。A 变了，B 不受影响。
- **高耦合（坏）：** 模块 A 强依赖模块 B 的内部细节。A 一变，B 就崩。（类似积木效应）

**「例子」**

- **低耦合：** 函数 A 调用函数 B，只传递参数，不关心 B 内部怎么实现。
- **高耦合：** 函数 A 直接修改了函数 B 内部的全局变量，或者 A 的代码里写死了 B 的类名。

**「总结」**


内聚（Cohesion）看内部： 关注“这个模块是否专注”。耦合（Coupling）看外部： 关注“模块之间是否独立”。


## 会议记录系统


**「项目」**


咪鼠的项目，当时做一个会议记录系统，左侧是音频界面，右侧是字幕界面。以音频时间做数据驱动整体的UI变化，比如字幕的同步，以及字幕的实时修改删除和添加以及高亮功能。点击字幕会导致时间轴的变化，时间轴的变化也会导致字幕的自动滚动，比较复杂的状态管理。


**「时间轴同步引擎」**

