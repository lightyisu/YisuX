---
catalog:
  - jishu
date: '2025-11-04 08:00:00'
type: Post
slug: htmltip
title: 面试 | 前端基础型
status: 已发布
urlname: 282e9dc9-c245-80da-83c6-f1711a1eb1f7
updated: '2026-01-20 22:36:00'
---

## 🍉 盒子模型


盒模型

- **Content（内容）**
- **Padding（内边距）**
- **Border（边框）**
- **Margin（外边距）**

默认**标准盒模型（谷歌盒）**


**(box-sizing: content-box)**


意思默认情况下写死css的width就是content的宽度


从content基础上加padding , margin, 就像建房子时，墙壁往外建的效果一样。


**(box-sizing: border-box)（IE盒）**


width是整个盒子模型的宽度


设定了width就是整个元素的宽度，就像房子固定了往屋子里建的效果。


**总结：不同盒模型的width计算不一样**


## 🍉 盒模型下的边距margin重叠-BFC / IFC


引言：两个div上下都有一定的margin 遇到的时候不会单纯的相加 比如上div margin 20px 下div margin 10px 他俩之间不会产生30px的margin而是合并为20px的margin


（当两个**垂直相邻**的**块级元素 (block-level element)** 的外边距相遇时，它们会合并（重叠）成一个外边距。合并后的外边距高度等于两个发生重叠的外边距中的**较大者**。）


**BFC 的核心意义在于“隔离”**。它创建一个独立的盒子，这个盒子内部的布局不会影响到外部，外部也不会影响内部。


### ① 防止“外边距塌陷”（Margin Collapsing）


在同一个 BFC 中，两个相邻块级元素的上下外边距会合并。

- **意义**：如果你想让两个盒子各留各的间距，给其中一个盒子包裹一层 BFC，它们就不再属于同一个上下文，边距就不会合并了。

### ② 清除内部浮动（解决高度塌陷）


当父元素内部全是浮动元素（`float`）时，父元素的高度会变为 0。

- **意义**：将父元素触发为 BFC（例如设置 `overflow: hidden` 或 `display: flow-root`），父元素就会“自动”去计算浮动子元素的高度，从而撑开容器。

### ③ 避免文字环绕（自适应两栏布局）


默认情况下，文字会环绕在浮动元素周围。

- **意义**：如果给右侧文字容器触发 BFC，它会变成一个“规矩的正方形”，不再钻到浮动元素的下面，从而轻松实现左侧固定、右侧自适应的布局。

BFC


触发条件：一个元素只要满足以下**任意一个条件**，就会创建新的 BFC：

- **根元素** **`<html>`**：本身就是一个 BFC。
- **`display: flow-root;`**：**现代首选！** 这是专门为了创建 BFC 而生的属性，没有任何副作用。
- **`overflow`**：值不为 **`visible`** 的元素（如 **`hidden`**, **`auto`**, **`scroll`**）。

![20260117_x3.jpg](https://r2.yisux.com/blog_img/20260117_x3.jpg)


## 🍉 Clear属性与浮动/BFC关系


**`clear`** 是一个 CSS **属性**，它应用于一个元素本身，用来规定该元素的哪一侧不允许其他浮动元素。

当一个元素设置了 **`clear: both`**，浏览器会确保这个元素的**上边框**位于所有在它之前出现的浮动元素的**下边框**之下。简单来说，就是把这个元素“推”到所有浮动元素的下方。



| **特性**    | **`clear: both`**        | **BFC (Block Formatting Context)** |
| --------- | ------------------------ | ---------------------------------- |
| **本质**    | 一个 CSS **属性**            | 一个 CSS **布局概念/规则**                 |
| **作用对象**  | 应用于**需要被清除的元素本身**        | 应用于**需要包含浮动元素的父容器**                |
| **工作方式**  | 将自身“推”到浮动元素下方            | 创建一个独立的“结界”，自动“包裹”住内部浮动            |
| **解决的问题** | 解决**后续元素**与**浮动元素**的并排问题 | 解决**父容器**因内部子元素浮动而导致的**高度塌陷**问题    |


## 🍉  堆叠上下文下的z-index


一个元素会创建自己的叠放上下文


如果某个父元素创建了一个独立 stacking context，则其内部元素的 z-index 再高，也**无法越过**这个父上下文之外的元素。

- **根元素 (****`<html>`****)**：天然的最底层上下文。
- **透明度**：`opacity` 小于 1。
- **CSS 变换**：使用了 `transform`（如 `scale` 或 `translate`）。
- **Flex/Grid 子元素**：当父级是 Flex/Grid 布局且子元素有 `z-index` 时。

例子：


| **元素**      | **CSS 属性**     | **结果**          |
| ----------- | -------------- | --------------- |
| **容器 A**    | `z-index: 1`   | 创建了上下文，层级为 1    |
| **子元素 A-1** | `z-index: 999` | 在 A 内部很高，但受限于 A |
| **容器 B**    | `z-index: 2`   | 创建了上下文，层级为 2    |


即使 **子元素 A-1** 的 `z-index` 是 999，它也**永远会被容器 B 挡住**。因为在父级竞争中，容器 A 已经输给了容器 B。这就是“拼爹”原则：**子元素的层级上限，取决于它所属的叠放上下文。**


**总结：z-index不是全局的有时候会被父元素的z-index束缚 导致实际上的提升z-index不起效果**


## 🍉  布局与Flex


一直以来基本上flex都是查 总结一下感觉稍微好点


把容器和item的属性分开看一下：


容器属性：

- flex-direction （设置方向 行列）
- flex-wrap （设置折行）
- flex-flow  （`flex-direction`属性和`flex-wrap`属性的简写）
- **justify-content** （主轴上的对齐方式）
- **align-items** （交叉轴上如何对齐）
- align-content （多根轴线的对齐方式）

项目属性：

- `order` （顺序）
- `flex-grow` （放大默认不放大）
- `flex-shrink` （缩小默认缩小）
- `flex-basis` （固定宽度）
- `flex` （简写）
- `align-self` （指定对齐覆盖`align-items`）

## 🍉  function.apply( )的方法


1.改变this的指向


**传统函数（****`function`** **声明的函数）的** **`this`** **指向是在函数被调用时才决定的，而不是在函数被定义时决定的。** 当一个函数被“独立”调用时（即没有作为对象的方法调用，没有用 **`new`**，也没有用 **`bind/call/apply`**），在非严格模式下，它的 **`this`** 默认指向全局对象 **`window`**。


**箭头函数**不遵循“调用时决定 **`this`**”的规则。


**`apply`** **vs** **`call`** **vs** **`bind`**


| 特性         | `call()`                                    | `apply()`                                      | `bind()`                                    |
| ---------- | ------------------------------------------- | ---------------------------------------------- | ------------------------------------------- |
| **参数传递方式** | **逐个列举** `func.call(this, arg1, arg2, ...)` | **数组形式** `func.apply(this, [arg1, arg2, ...])` | **逐个列举** `func.bind(this, arg1, arg2, ...)` |
| **函数执行时机** | **立即执行**                                    | **立即执行**                                       | **不立即执行**，返回一个**新的、绑定了 this 的函数**           |
| **返回值**    | 函数的执行结果                                     | 函数的执行结果                                        | 一个新的函数                                      |


## 🍉  防抖


很久都记不起防抖节流了。


一般来说需要一个闭包存储一个共享变量。


原理是不断重置更新settimeout函数 只有最后一次操作经过设置time后才算执行


总结：


**防抖**就是不断清空定时器然后添加新的 使得操作不断延后 最后一次操作为准


**“你触发得太快了，等你停下来歇一会儿我再执行。”**


**节流**就是不断查看时间差（这次和上一次） 如果没超过就不操作 超过这个时间再操作并更新时间


**“我不管你触发多少次，我只在固定时间执行一次。”**


闭包是实现两个的天选之子，**解决状态的持久化（私有且独立的状态）和封装问题**。



## 🍉 原型链和继承


原型链是 JavaScript 中用于实现继承和属性查找的一种机制。每个对象都有一个原型对象（prototype）。通过原型对象可以实现属性和方法的继承。


JavaScript 引擎会沿着原型链向上查找，直到找到相应的属性或方法或者到达原型链的顶端（Object.prototype）为止。


没有ES6之前的继承：


有3步：


 01 继承属性 ，Animal.call(this, name)


02 通过连接原型链完成继承 ，Dog.prototype = Object.create(Animal.prototype)


03 再加上 constructor， Dog.prototype.constructor = Dog


```typescript
function Animal(name) {
  this.name = name;
}
 
Animal.prototype.hello = () => {
  console.log("hello");
};
 
function Dog(name, say) {
  // 01 继承属性
  Animal.call(this, name);
  this.say = say;
}
 
// 02 通过连接原型链完成继承
Dog.prototype = Object.create(Animal.prototype);
 
// 03 再加上 constructor
Dog.prototype.constructor = Dog;
// Reflect.defineProperty(Dog.prototype, "constructor", {
//  value: Dog,
//  enumerable: false, // 不可枚举
//  writable: true
// })
```


有ES6就非常简单了：


```typescript
class Animal {
  constructor(name) {
    this.name = name;
  }
 
  hello() {
    console.log("hello");
  }
}
 
class Dog extends Animal {
  constructor(name, say) {
    super(name);
    this.say = say;
  }
}
```


![20260117_x4.jpg](https://r2.yisux.com/blog_img/20260117_x4.jpg)


## 🍉  **new 的时候发生了什么**

1. 创建了一个新对象 { }
2. 链接到原型 const instance = Object.create(fn.prototype);
3. 绑定this指向 fn.apply(instance, args);

  4.   返回这个对象 { }


## 🍉_**proto_**、prototype、constructor 的关系


prototype（核心）: 原型，可以放一些用于子类继承的方法和属性 | 图纸


_proto_:原型链，用以指向自己的父原型（指向prototype）| 标签指向图纸


constructor **:**指回创建这个原型对象的那个构造函数 （实例对象找构造函数用）


## 🍉在类里，为什么将属性放在 this 上，方法放在 prototype 上


可以看到好像所有的属性都定义在this上，所有的共享方法都在链上这是为什么呢？


1.咋不把属性写到链上？


其实是个大聪明想法，极其容易重名，一改动全身。


**大部分要继承的属性都是私有的更好 私有属性必须放在 this 上。**


2.咋不把方法写到this上？


**非常占用内存 而且好像不好继承吧（理论上也可以用super or call）。**


3.class是语法糖 实际上咱们的方法还是和属性分开了写到链上的


**总结：所有属性在 this 上，所有共享方法在链上。**


## 🍉 事件循环


事件循环无非宏任务和微任务但是我一直也挺混乱的 问了GLM给了我一个例子我觉得很不错


主要是所有的代码都是两类：一类宏一类微任务 **同步代码会先执行完**

- **宏任务**：包括 **`script`** (整体代码)、**`setTimeout`**、**`setInterval`**、I/O 操作、UI 渲染等。每次执行一个宏任务后，会检查微任务队列。
- **微任务**：包括 **`Promise.then()`**、**`Promise.catch()`**、**`Promise.finally()`**、**`process.nextTick`** (Node.js) 等。在一个宏任务执行完毕后，会立即清空所有微任务。

example:


```typescript
setTimeout(() => console.log(0));
new Promise((resolve) => {
  console.log(1);
  resolve(2);
  console.log(3);
}).then((o) => console.log(o));
 
new Promise((resolve) => {
  console.log(4);
  resolve(5);
})
  .then((o) => console.log(o))
  .then(() => console.log(6));
```


重点是**整体代码也属于宏任务，在一个宏任务执行完毕后，会立即清空所有微任务。**


**第一阶段：执行主脚本（这是一个宏任务）**

- 宏任务队列: **`[setTimeout(callback 0)]`**
- 微任务队列: **`[]`**

**new Promise((resolve) => { ... })**

- 宏任务队列: **`[setTimeout(callback 0)]`**
- 微任务队列: **`[then(callback 2)]`**

**new Promise((resolve) => { ... })**

- 宏任务队列: **`[setTimeout(callback 0)]`**
- 微任务队列: **`[then(callback 2), then(callback 5)]`** (注意入队顺序)

**第二阶段：主脚本执行完毕，清空微任务队列**


取出第一个微任务：**`then(callback 2)`**


取出第二个微任务：**`then(callback 5)`**


触发链式调用的下一个 **`.then()`** **放入** **`then(callback 6)`**


微任务队列不为空，继续执行 取出微任务：**`then(callback 6)`**


**第三阶段：微任务队列已清空，执行下一个宏任务**


取出宏任务：**`setTimeout(callback 0)`**


总结：**一宏完清所有（这个宏产生的）微 再下一个宏** 

- **宏任务**：**由浏览器/Node.js宿主环境提供（script、setTimeout、setInterval、I/O、UI渲染等）在事件循环的每个阶段执行，需要等待微任务队列清空后才开始 低优先级、延迟执行、任务量大**
- **微任务**：**由JavaScript引擎内部产生（Promise、async/await、process.nextTick等）在当前宏任务执行完成后立即执行，在下一个宏任务开始前清空 高优先级、立即执行、任务量小**

![result_KvpDqN.jpg](https://r2.yisux.com/blog_img/result_KvpDqN.jpg)


## 🍉 V8垃圾回收


V8 的垃圾回收（Garbage Collection, GC）机制是 JavaScript 高效运行的基石，其核心设计理念是建立在分代假说（The Generational Hypothesis）之上的。


分代假说主要有两个核心观点：

1. 大多数对象在内存中存活的时间很短（即“朝生夕死”）。
2. 不死对象，往往会活得更久。

基于此，V8 将堆内存划分为**新生代（Young Generation）和老生代（Old Generation）**，并对它们采用完全不同的回收策略。


| **分代**              | **内存大小**           | **特点**           | **回收频率** |
| ------------------- | ------------------ | ---------------- | -------- |
| **新生代 (New Space)** | 较小 (通常 1MB - 64MB) | 存放新生的、生命周期短的对象   | 极高       |
| **老生代 (Old Space)** | 较大                 | 存放从新生代晋升的对象、常驻对象 | 较低       |


**新生代**采用 **Scavenge 算法**，通过在两个空间中高频“复制存活对象”来快速清理短命对象并消除碎片；**老生代**则采用 **Mark-Sweep（标记清除）** 和 **Mark-Compact（标记整理）** 策略，通过“原地标记、清理与内存压缩”来高效管理长寿的大型对象；两者相互配合，并辅以增量标记与并发回收技术，在确保内存利用率的同时，极大地减少了因垃圾回收导致的程序卡顿。


**GC 的基本原理：****可达性** **(这个联系到内存泄漏）**


在像 C/C++ 这样的语言中，开发者需要手动分配和释放内存（**`malloc`**/**`free`**）。这非常强大，但也极易出错，容易导致**内存泄漏**（忘记释放）或**悬空指针**（释放后继续使用）。


JavaScript 作为一门高级语言，为了提升开发效率和程序稳定性，引入了**自动内存管理**，其核心就是**垃圾回收机制**。


任何从“根”出发无法访问到的对象，都被认为是“不可达的”或“死”的，这些就是 GC 需要回收的目标。







## 🍉 script (async/defer)



### **script**


浏览器在解析 HTML 的时候，如果遇到一个没有任何属性的 script 标签，就会**阻塞解析**，先发送网络请求获取该 JS 脚本的代码内容，然后让 [JS 引擎](https://zhida.zhihu.com/search?content_id=153230340&content_type=Article&match_order=1&q=JS%20%E5%BC%95%E6%93%8E&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3Njg4MjQ3MTEsInEiOiJKUyDlvJXmk44iLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxNTMyMzAzNDAsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.rOAPEaPZT7nPxxgv1mPRo8C7dfrLNNewqNvlXJ7IkMU&zhida_source=entity)执行该代码，当代码执行完毕后恢复解析。


![v2-566e1583691ad6fdf6479bd21a2d549c_r.jpg](https://pica.zhimg.com/v2-566e1583691ad6fdf6479bd21a2d549c_r.jpg)


### **async script（加载不阻塞执行阻塞）**


请求该脚本的网络**请求是异步**的，**不会阻塞**浏览器解析 HTML，一旦网络请求回来之后，


**如果此时 HTML 还没有解析完**，浏览器会暂停解析，先让 JS 引擎执行代码，执行完毕后再进行解析（特性适合广告统计，因为怕解析完人都走了还没统计和投放广告）


![20260118_x1.png](https://r2.yisux.com/blog_img/20260118_x1.png)


**如果HTML 已经解析完毕了**那就啥事没有


![20260118_x2.png](https://r2.yisux.com/blog_img/20260118_x2.png)


async 是不可控的，因为执行时间不确定，你如果在异步 JS 脚本中获取某个 [DOM 元素](https://zhida.zhihu.com/search?content_id=153230340&content_type=Article&match_order=1&q=DOM%20%E5%85%83%E7%B4%A0&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3Njg4MjQ3MTEsInEiOiJET00g5YWD57SgIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MTUzMjMwMzQwLCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.4PlWzECu5inR35GFCRycYM7q99pb8FusuiIJhyZJqjM&zhida_source=entity)，有可能获取到也有可能获取不到。而且如果存在多个 async 的时候，它们之间的执行顺序也不确定，完全依赖于网络传输结果，谁先到执行谁。


### **defer script（全不阻塞）**


当浏览器遇到带有 defer 属性的 script 时，获取该脚本的网络请求也是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器不会暂停解析并执行 JS 代码，而是等待 HTML 解析完毕再执行 JS 代码。（HTML解析优先、自身执行按照顺序）


![20260118_x3.png](https://r2.yisux.com/blog_img/20260118_x3.png)


| 特性                | `<script>` (无属性)           | `<script async>`    | `<script defer>`                |
| ----------------- | -------------------------- | ------------------- | ------------------------------- |
| **下载是否阻塞HTML解析？** | **是**                      | **否** (并行下载)        | **否** (并行下载)                    |
| **执行是否阻塞HTML解析？** | **是**                      | **是** (下载完后立即执行)    | **否** (在HTML解析完成后执行)            |
| **执行顺序**          | **顺序** (文档顺序)              | **无序** (谁先下载完谁先执行)  | **顺序** (文档顺序)                   |
| **何时执行？**         | 立即下载，立即执行                  | 下载完成后立即执行           | HTML解析完成后，`DOMContentLoaded` 之前 |
| **适用场景**          | 极少使用，除非脚本必须立即执行并影响后续HTML渲染 | **独立的第三方脚本**，如统计、广告 | **有依赖关系的应用主脚本**，如JS框架、应用逻辑      |


## 🍉 回调/promise/**generator**/async


回调地狱→promise：链式调用解决回调嵌套→async：更同步风的promise语法糖（本质generator+promise）


**Generator 本身是一个同步的、用于控制执行流程的工具。它之所以与异步编程紧密相连，是因为它的“暂停/恢复”特性为管理异步操作提供了一种革命性的新思路，催生了** **`async/await`** **这种终极解决方案。**


## 🍉 数据类型


JavaScript 目前包含八种数据类型，其中可以分成两大类。


基本数据类型（原始值）：

- Number（数值，包含NaN）
- String（字符串）
- Boolean（布尔值）
- Undefined（未定义/未初始化）
- Null（空对象）
- Symbol（独一无二的值，ES6 新增）
- BigInt （大整数，能够表示超过 Number 类型大小限制的整数，ES 2020新增）

**3+2+2分类更好区别**


引用数据类型（引用值）：

- Object（对象。Array/数组 和 function/函数 也属于对象的一种）

## 🍉 **包装对象**


**包装对象解释了为什么像** **`string`****、****`number`****、****`boolean`** **这样的基本数据类型，却能调用方法和访问属性？**


基本类型 **没有属性和方法**：这是基本定义，一个纯粹的值不应该有复杂的行为。


包装对象是 JavaScript 内置的一种特殊对象，它“包装”了基本类型的值，并提供了一系列有用的属性和方法来操作这个值。


主要有三种包装对象：

- **`String`** 对象：包装 **`string`** 基本类型。
- **`Number`** 对象：包装 **`number`** 基本类型。
- **`Boolean`** 对象：包装 **`boolean`** 基本类型。

理论上基本类型和对象是矛盾的 基本类型不能用new **强烈不推荐显式创建包装对象 因为这样做挺奇怪的**


JavaScript 引擎在幕后完成了一切。这个过程被称为 **“自动装箱”**。



引擎会**立即、临时地**创建一个 **`String`** 对象的实例，这个实例的内容与 **`str`** 的值相同。


```javascript
let str = "hello";
let upperStr = str.toUpperCase();
```


**`// 引擎内部悄悄执行：let tempObj = new String("hello");`**


引擎在这个**临时对象**上调用 **`toUpperCase()`** 方法


最后返回结果并销毁


总结：自动装箱，临时创建用完销毁


## 🍉 vue的ref和reactive


### **ref（响应式包装对象）**


vue的ref用的比较通用，因为把基本类型通过ref转化成了一个（响应式）包装对象（类似js里的自有内置的String,Number虽然他们也是基本类型但是也有方法和属性）。这样就能够具有响应式了。ref通过`.value` 可以**随意替换基本类型的值**还能够保持响应式。


这个也非常好理解毕竟整个包装对象上有很多属性和方法，只是替换了**`value属性`**当然不会对其造成影响。


### **reactive （Proxy）**


vue的reactive就只为引用类型而生，就是用于object类型。


因为**他不是包装对象，他是返回一个对象的响应式代理proxy**所以他也不具有value，替换整个对象那就是直接变成了其他东西和reactive直接无关了。用法接近原生对象不需要value所以适合放入对象。


然后这又引出一个问题：


### vue的底层响应式不是proxy为什么看起来只有reactive用了？


Vue 3 的响应式框架逻辑（Track/Trigger）是基于 Proxy 重新设计的，但针对不同的数据类型，它的“入口”策略不同。


简单来说：**`ref`** **是** **`reactive`** **的超集（或者说补丁）。**


**JavaScript 的限制**：**Proxy 只能代理“对象”（Object），不能代理“基本类型”（Primitive）**。必须先手动构建一个对象（即“包装对象” 这在内置JS系统也有体现 自动装箱的String/Number）。


## 🍉 vue的响应式原理DOM渲染


核心：订阅发布的设计模式


**当数据变化时，自动重新执行那段“依赖这些数据”的代码。** 在 Vue 中，这段代码通常就是**组件的渲染函数**。


### 第一步：初始化与订阅（Track - 依赖收集）


当一个组件开始挂载（Mount）时，Vue 会创建一个 **渲染 Effect**。这个 Effect 会包裹着组件的 `render` 函数。

- **执行渲染函数**：为了生成虚拟 DOM，渲染函数会读取响应式数据（如 `ref.value`）。
- **触发 Getter**：当你读取 `ref.value` 时，触发了它的 `get` 拦截。
- **收集依赖**：Vue 此时知道：“噢，这个组件的渲染函数依赖了这个变量。” 于是它把这个渲染 Effect 存入该变量对应的“订阅名单”里。

### 第二步：数据变动（Trigger - 派发更新）


当你执行 `count.value++` 时，会触发响应式数据的 `set` 拦截（Proxy 的 `set` 或 ref 的 `setter`）。

- **通知邮局**：Setter 被调用，它会立刻翻开自己的“订阅名单”。
- **取出订阅者**：名单上记着刚才那个“渲染 Effect”。

### 第三步：异步排队（Scheduler - 调度）


这是 Vue 性能优化的关键。Vue **不会**在数据变动的一瞬间立刻去刷 DOM。

- **放入微任务队列**：Vue 会把这个需要执行的 Effect 丢进一个异步队列。
- **去重与合并**：如果你在 1 毫秒内改了 100 次数据，Vue 只会把渲染 Effect 排入队列一次。
> 知识联动：这里用到的就是你之前提到的 JS 事件循环。渲染更新被当作一个微任务（Microtask）。

### 第四步：执行更新（Patch - 虚拟 DOM 比对）


当主线程任务完成，开始清理微任务队列时，渲染 Effect 正式执行：

- **生成新 VNode**：重新执行渲染函数，得到一套新的虚拟 DOM 树。
- **比对（Diff）**：Vue 将新旧两棵虚拟 DOM 树进行对比，算出最小的变更补丁。

### 第五步：刷新 DOM（Commit）


最后一步，Vue 把计算出来的差异（Patch）应用到**真实的 DOM 节点**上。此时，你在屏幕上看到了数据的变化。


## 🍉 vuex/pinia内部如何实现的数据共享


三个关键步骤：


1.创建一个store的响应式容器保证共享


2.注入到Vue实例中，实例的所有组件可以访问


3.使用规范化的API**(**如 **`state`****,** **`getters`****,** **`actions`**)追踪行为


**Vuex 的内部实现** 


1.利用 Vue 的响应式 API 创建响应式的Store


2.使用**Vue.mixin**在所有组件的 **`beforeCreate`** 生命周期钩子中，将 **`$store`** 这个属性注入到每个组件实例中。这样，你在任何组件里都可以通过 **`this.$store`** 访问到同一个 Store 实例。
（这里使用的mixin 3已经不用了 简单回忆mixin就是复用逻辑用的 以便在不同组件复用一个相同的逻辑 3直接定义一个普通函数就可以）


3.Vuex 强制规定，修改 `state` 的唯一途径是提交 **`mutation`**。**`mutation`** 必须是同步函数。这确保了每一次状态变更都是一个可追踪的、原子化的操作，便于调试和时间旅行。


**`action`** 负责处理异步操作（如 API 请求），然后 **`commit`** 一个 **`mutation`** 来改变状态。它不直接修改状态。


**Pinia 的内部实现**


1.使用 Vue 3 暴露出的 **`reactive`** 函数，将你定义的 **`state`** 对象包装成一个响应式代理对象。
2.完全基于 **`provide`****/****`inject`**：**`app.use(createPinia())`** 会创建一个 Pinia 根实例，并通过 **`app.provide`** 将其提供给整个应用树。


3.直接修改无须异步中同步


**为什么 Vuex 需要“异步中同步提交”**

1. 为了 Vue DevTools 的“时间旅行”调试 (vue3 更好的devtools)
2. Vue 2 响应式系统的限制 （vue3 proxy了解决了）

### 为什么 Proxy 让 Pinia 可以放弃 Mutation？


`Proxy` 的监控是“全自动”且“全方位”的。在 Pinia 中，无论你在 Action 里如何修改状态（哪怕是动态增加一个新字段），`Proxy` 都能第一时间捕捉并通知系统进行依赖更新。


defineProperty 只能监听“已定义的属性”


它不能监听：

- 新增属性
- 删除属性
- 复杂结构的变化（数组变更、深层变更）

    → Vuex 必须通过 Mutation 来“收集依赖”和“触发更新”。


## 🍉 vue组件的通信方式


| 通信方式                           | 适用场景         | Vue 版本 | 备注                                 |
| ------------------------------ | ------------ | ------ | ---------------------------------- |
| **`Props`**                    | 父 → 子        | All    | **最基础**，单向数据流。                     |
| **`$emit`**                    | 子 → 父        | All    | **最基础**，子组件通知父组件。                  |
| **`provide`****/****`inject`** | 跨级/隔代        | All    | 解决 "props drilling" 问题。            |
| **Pinia / Vuex**               | 任意组件         | All    | **最强大**，集中式状态管理，推荐用于中大型项目。         |
| **`$refs`** **/** **`ref`**    | 父 → 子 (直接访问) | All    | **谨慎使用**，用于命令式操作，会破坏封装。            |
| **事件总线**                       | 任意组件         | Vue 2  | Vue 3 中不推荐，建议用 Pinia 或 `mitt` 库替代。 |


## 🍉为什么vue3不需要事件总线了


主要因为 **Composition API + provide/inject + 更强的状态管理模式** 已经覆盖了过去 Event Bus 的主要使用场景


以前事件总线的主要解决痛点是兄弟组件通信，现在可以通过解构出一个共享状态实现


通过 **reactive + ref** 实现共享状态：


```typescript
// useUser.ts
export const user = reactive({ name: 'xx' })
```


兄弟组件只需 import 这个模块即可共享，替代 Event Bus。


Event Bus 是一种“全局隐式消息通道”，抽象层级过低，不利于大型系统维护。


## 🍉 **`async`** **函数总是返回一个 Promise**


**任何一个函数，只要在它前面加上了** **`async`** **关键字，那么这个函数的返回值就自动被包装成一个 Promise 对象。**


```typescript
// 一个简单的 async 函数，它返回一个数字
async function getNumberAfterDelay(num) {
  await new Promise(resolve => setTimeout(resolve, 1000)); // 模拟1秒延迟
  return num;
}

const numbers = [10, 20, 30];

// 使用 map 和 async 函数
const promises = numbers.map(getNumberAfterDelay);

console.log(promises);
// 立即输出：
// [
//   Promise { <pending> },
//   Promise { <pending> },
//   Promise { <pending> }
// ]

// 等待所有 Promise 完成
setTimeout(() => {
  console.log(promises);
  // 1秒后输出：
  // [
  //   Promise { <fulfilled>: 10 },
  //   Promise { <fulfilled>: 20 },
  //   Promise { <fulfilled>: 30 }
  // ]
}, 1500);
```


## 🍉  js的内存泄漏


JS 的内存管理机制。JavaScript 具有自动垃圾回收（GC）机制，GC 会定期（或在特定时机）扫描内存，找出那些“不再被使用”的变量，然后释放它们占用的内存。判断“不再被使用”的标准通常是“可达性”——即从根对象（如 **`window`**、**`global`**）出发，能否访问到这个对象（从根对象，沿着引用链，能否找到它，只要有引用就不销毁）。如果访问不到，GC 就会回收它。


本应被回收的内存，因为某种原因被无意中持有了引用，导致它一直“可达”，无法被 GC 释放。只要有一点联系就不会被垃圾回收机制所回收，例如闭包。


**1. 意外的全局变量**


在非严格模式下，如果一个变量在声明时没有使用 **`var`**、**`let`** 或 **`const`**，它会被自动挂载到全局对象（浏览器中的 **`window`**）上。全局对象的生命周期与页面一致，只要页面不关闭，它上面的变量就永远不会被回收。


```javascript
function createLeak() {
  // "leakyData" 没有被声明，它会成为 window.leakyData
  leakyData = new Array(1000000).fill('*'); 
}

createLeak(); // leakyData 现在是一个全局变量，无法被回收
console.log(window.createLeak) //现在createLeak被挂到了window上


let cl2=function createLeak2() {
  // "leakyData" 没有被声明，它会成为 window.leakyData
  leakyData = new Array(1000000).fill('*'); 
}
console.log(window.cl2) //undefined 现在挂不上了 会自动被回收


x=1;
=>1
window.x
=>1
```


**不用变量声明就会内存泄漏 自动挂window上（window只要不关闭就不销毁）**


**2.未清理的定时器或回调**


**`setInterval`** 或 **`setTimeout`** 的回调函数，如果被无限期地执行且没有被清理，那么它引用的所有外部变量都将无法被释放


```javascript
let largeObject = { data: new Array(1000000) };

setInterval(() => {
  // 这个回调函数引用了外部的 largeObject
  // 只要定时器在运行，largeObject 就不会被回收
  console.log(largeObject.data.length); 
}, 1000);

// 即使后续不再需要 largeObject，它也无法被回收
largeObject = null; // 无效！定时器回调仍持有引用
```


在不需要定时器时，务必使用 **`clearInterval()`** 或 **`clearTimeout()`** 来清除它


**3.闭包**


一个内部函数可以访问其外部函数的变量。如果这个内部函数被长期引用（例如，作为事件回调），那么即使外部函数已经执行完毕，其作用域链上的变量也不会被销毁。


解决方法：使用完后将其设为 **`null`**


**4.DOM 引用和 JS 对象相互引用**


DOM 被删除了，但 JS 中仍有引用 → 不能回收。


或者 JS 对象被 DOM 属性绑定着 → 不能回收。


```javascript
let detachedElement = document.getElementById('my-element');

// 从 DOM 中移除了这个元素
detachedElement.remove(); 

// 但是，JS 变量 detachedElement 仍然持有对它的引用
// 这个 DOM 元素及其关联的所有资源都无法被 GC 回收
console.log(detachedElement); // 依然可以访问到
```


**5.被遗忘的事件监听器**


在单页应用（SPA）中，这个问题尤为突出。当页面切换或组件销毁时，如果忘记移除绑定在 DOM 元素或 **`window`**/**`document`** 上的事件监听器，这些监听器的回调函数及其闭包引用的变量都无法被释放。


毕竟组件化了以后挂在window是真的挂上去了而销毁组件只是window下的一小部分。


**6.忘记清理大型数据结构（Map / Set 不当使用）**


因为这些大型数据结构通常引用永远存在 永远可达。


WeakMap / WeakSet 的键是弱引用，不会阻止垃圾回收。


**（使用** **`Map`** **- 强引用）**


```javascript
const userInfo = new Map();
let user1 = { name: '张三' };
userInfo.set(user1, 'VIP用户'); //强引用

// ... 后来，user1 不再需要了
user1 = null;

// 问题：{ name: '张三' } 对象无法被回收，因为 userInfo 还强引用着它！
// 这就是内存泄漏。
```


**（使用** **`WeakMap`** **- 弱引用）**


```javascript
const userInfo = new WeakMap();
let user1 = { name: '李四' };
userInfo.set(user1, 'VIP用户');//弱引用

// ... 后来，user1 不再需要了
user1 = null;

// 结果：{ name: '李四' } 对象可以被正常回收！
// WeakMap 中关于 user1 的条目也会随之自动消失。
// 没有内存泄漏！
```


| 泄漏类型           | 核心原因                            | 关键解决方案                              |
| -------------- | ------------------------------- | ----------------------------------- |
| **意外的全局变量**    | 变量未声明，被挂到 `window` 上            | 使用 `'use strict'` 和 `let`/`const`   |
| **被遗忘的定时器**    | `setInterval`/`setTimeout` 未被清除 | 及时调用 `clearInterval`/`clearTimeout` |
| **闭包**         | 长期存在的内部函数引用了外部变量                | 理解闭包生命周期，手动解除引用                     |
| **分离的 DOM 节点** | DOM 已移除，但 JS 变量仍持有引用            | 移除 DOM 后，将 JS 引用设为 `null`           |
| **被遗忘的事件监听器**  | 组件销毁时未移除监听器                     | 在组件销毁生命周期中移除监听器                     |
| **不当的缓存**      | `Map`/`Set` 强引用了缓存对象            | 对于对象**键**，优先使用 `WeakMap`/`WeakSet`  |


## 🍉 弱引用 and 强引用


**强引用**


```javascript
let book = { title: 'JavaScript高级程序设计' }; // 你把书借出来了
// ... 你一直持有 book 这个引用
// 只要 book 变量还存在且不为 null，这本书就不会被回收
```


**弱引用 (ES6)**


弱引用是一种不“拥有”对象的引用。它不会阻止垃圾回收器回收对象。这是ES6的新特性，ES5之前不存在这个特性。

- **WeakMap / WeakSet** 是 ES6 新增的内置数据结构
- 它们内部持有 **弱引用（weak reference）**
- 允许做缓存或附加元数据，而不用担心泄漏

```javascript
let book = { title: '你不知道的JavaScript' };
const bookMetadata = new WeakMap(); // 这是一个特殊的目录系统

// 你把这本书的信息登记到了目录系统里，但这不是“借出”
bookMetadata.set(book, { category: 'Front-end', popular: true });

// 现在，你把书还了，不再持有它
book = null; // 所有的强引用都消失了

// 此时，GC 会发生什么？
// GC 发现没有任何强引用指向那本书了，于是把它回收了。
// 同时，WeakMap 里的那个条目也会自动消失！
// 因为 WeakMap 的机制就是：“如果键（那本书）没了，我这条记录也没用了”。
```


总结：其实就是对象键回收的问题


## 🍉 判断数据类型的方式有哪些


### **1.typeof - 最基础但最“坑”的方法 判断基本类型很方便**


```javascript
typeof "hello";        // "string"
typeof 123;            // "number"
typeof true;           // "boolean"
typeof undefined;      // "undefined"
typeof Symbol();       // "symbol"
typeof 123n;           // "bigint"
typeof function() {};  // "function"

// --- 以下是 typeof 的“坑” ---
typeof null;           // "object"  (这是一个历史遗留的 bug)
typeof [];             // "object"
typeof {};             // "object"
typeof new Date();     // "object"
typeof /regex/;        // "object"
```

- **最大的问题**：**`typeof null`** 返回 **`"object"`**，这是 JS 早期设计的一个错误。
- 无法区分具体的对象类型，比如数组、日期、正则表达式等，它们都返回 **`"object"`**
- **`typeof`**：**可以**用来准确判断 **`undefined`**，但**不能**用来判断 **`null`**

### **2.instanceof - 检查原型链**


```javascript
[] instanceof Array;        // true
[] instanceof Object;       // true (Array.prototype.__proto__ === Object.prototype)
new Date() instanceof Date; // true
new Date() instanceof Object; // true

function Person() {}
let p = new Person();
p instanceof Person;        // true
p instanceof Object;        // true

123 instanceof Number;      // false (基本类型不是对象实例)
"hello" instanceof String;  // false
```


专属于对象引用类型的判断方法


**不能用于判断基本类型（因为JS里的看起来像基本类型的引用对象是包装对象）**


**`instanceof`**：**完全不能**用来判断 **`undefined`** 和 **`null`**。


### **3.Object.prototype.toString.call() - 最准确、最通用的“终极”方法**


看起来是我们的大Object上的原型方法toString


这是目前判断数据类型最可靠、最精准的方法。所有内置对象都重写了 **`toString`** 方法，但 **`Object.prototype`** 上的原始 **`toString`** 方法会返回一个由 **`[object Type]`** 格式组成的字符串，其中 **`Type`** 就是对象的类型。


**为什么用** **`.call()`****？**


因为很多对象自身有 **`toString`** 方法，会覆盖 **`Object`** 上的。我们想借用 **`Object`** 上的 **`toString`** 方法，并让它在 **`variable`** 这个对象上执行。


```javascript
Object.prototype.toString.call("hello");        // "[object String]"
Object.prototype.toString.call(123);            // "[object Number]"
Object.prototype.toString.call(true);           // "[object Boolean]"
Object.prototype.toString.call(undefined);      // "[object Undefined]"
Object.prototype.toString.call(null);           // "[object Null]"  <-- 唯一能准确判断 null 的方法！
Object.prototype.toString.call(Symbol());       // "[object Symbol]"
Object.prototype.toString.call(123n);           // "[object BigInt]"
Object.prototype.toString.call(function() {});  // "[object Function]"

Object.prototype.toString.call([]);             // "[object Array]"
Object.prototype.toString.call({});             // "[object Object]"
Object.prototype.toString.call(new Date());     // "[object Date]"
Object.prototype.toString.call(/regex/);        // "[object RegExp]"
```


### 4.**`Array.isArray()`** **- 数组的专属方法**


| 方法                                     | 优点          | 缺点                           | 推荐场景                                                           |
| -------------------------------------- | ----------- | ---------------------------- | -------------------------------------------------------------- |
| **`typeof`**                           | 简单、快速       | `null` 误判为 `object`，无法区分对象类型 | 判断基本类型（`string`, `number`, `boolean`, `undefined`, `function`） |
| **`instanceof`**                       | 可区分对象类型     | 无法判断基本类型，有跨域问题               | 判断自定义类实例，在同一全局域内判断内置对象                                         |
| **`Object.prototype.toString.call()`** | **最准确、最通用** | 写法繁琐                         | **构建通用类型判断工具函数**                                               |
| **`Array.isArray()`**                  | **判断数组最可靠** | 只能判断数组                       | **任何需要判断数组的场景**                                                |


5.判断undefined和null


推荐严格相等**`=== null || === undefined`**


## 🍉 为什么需要reflect和proxy

- **Proxy（代理）**：让你可以**拦截并自定义**对象的基本操作（如属性查找、赋值、枚举、函数调用等）。
- **Reflect（反射）**：提供了一套**统一的、函数式的默认操作**，与 Proxy 的拦截方法一一对应。

**为什么需要 Proxy？—— 为了“拦截”与“控制”**


Proxy 可以拦截多达 13 种操作，几乎涵盖了对象的所有行为


**为什么需要 Reflect？—— 为了“统一”与“规范”**


Reflect 将所有对象操作都变成了函数形式，与 Proxy 的拦截器一一对应。


总结：这两个搭配使用，Proxy本来就是小幅度的改动式的拦截，配合Reflect默认行为搭配出一套拦截的逻辑。**`Proxy`** **赋予了“拦截”和“重定义”对象行为的权力，而** **`Reflect`** **提供了一个干净、统一的工具来执行那些被你拦截的“默认行为”。 JavaScript 元编程领域里相辅相成的两大利器。**


## 🍉 js 是面向对象语言吗


不是我觉着算不上，有面向对象逻辑的基于原型链的语言。ES6的class只是语法糖。


完全支持 OOP 的三大特性


| OOP特性             | JS 是否支持 | 示例        |
| ----------------- | ------- | --------- |
| 封装（Encapsulation） | ✔       | 对象、闭包     |
| 继承（Inheritance）   | ✔       | 原型链       |
| 多态（Polymorphism）  | ✔       | 方法重写、鸭子类型 |


JavaScript 不是传统类式的面向对象语言，而是基于原型（prototype）的面向对象语言。


## 🍉  面向对象特性


**封装“隐藏细节，提供接口”：**


封装，顾名思义，就是**将数据和操作数据的方法捆绑在一起，形成一个独立的“对象”，并对外部隐藏对象的内部实现细节**。


它就像一个黑盒子：

- **内部**：包含了对象的状态（属性/数据）和行为（方法/函数）。
- **外部**：只能通过盒子提供的特定接口（公共方法）来与它交互，而不能直接伸手进去乱动。

**继承  “代码复用，建立层次”**


继承允许我们创建一个新类（**子类/派生类**），这个新类可以**获取**另一个已存在的类（**父类/基类**）的所有属性和方法。这是一种 "is-a"（是一个）的关系。

- **代码复用**：避免编写重复的代码，是 DRY (Don't Repeat Yourself) 原则的体现。
- **逻辑清晰**：建立了一个从一般到特殊的类层次结构，符合人类的认知习惯。
- **为多态奠定基础**：没有继承，多态就无从谈起。

**多态  “同一接口，多种状态，不同实现”**


在面向对象中，它指的是**同一个行为（方法调用），作用于不同的对象，会产生不同的执行结果**。

- **灵活性**：允许我们将不同类型的对象视为同一类型来处理，大大降低了代码的耦合度。
- **可扩展性**：当需要增加一种新的动物（比如 **`Pig`**）时，我们只需要创建一个新的 **`Pig`** 类并实现“叫”的方法，而不需要修改调用“叫”这个动作的代码。这完美符合“开闭原则”。

**抽象**


核心思想：只关注对象必要的本质特征和行为，而忽略与当前目标无关的、非本质的细节。先不去实现具体的细节，是一种更高层更通用共享的实现。


[鸭子类型](https://zhida.zhihu.com/search?content_id=118496224&content_type=Article&match_order=1&q=%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NjM5MDgxNTQsInEiOiLpuK3lrZDnsbvlnosiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMTg0OTYyMjQsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.toRoeGMvbvXDlPVJx_rsZUMm_n9hrGt43krirP-KP9k&zhida_source=entity)


**抽象 vs. 封装：抽象是目标，封装是实现手段**


**封装是实现抽象的一种具体技术**。通过访问修饰符（**`public`**, **`private`**），我们把抽象出的“接口”和隐藏的“实现细节”分离开。


**抽象 vs. 继承：继承建立了抽象的层次结构**


继承本身就是一种抽象。我们通过提取多个子类的共同特征，来创建一个更抽象的父类。


**抽象 vs. 多态：多态是抽象的体现和结果**


正是因为我们可以将 **`Dog`**、**`Cat`** 等具体对象**抽象**地看作 **`Animal`** 类型，我们才能使用多态。


## 🍉**JS 内存管理基础：栈与堆**


JS 的内存主要分为两部分：


### **栈**

- **作用**：存储**原始类型**的数据（**`string`**, **`number`**, **`boolean`**, **`null`**, **`undefined`**, **`symbol`**, **`bigint`**）和**对象的引用地址**。更重要的是，它管理着**函数的调用**（执行上下文）。
- **特点**：空间小，但读写速度快。它是一种“后进先出”（LIFO）的数据结构。

### **堆**

- **作用**：存储**引用类型**的数据，如对象、数组、函数等。这些数据大小不固定，所以放在堆里。
- **特点**：空间大，但读写速度相对较慢。内存分配是动态的。

## 🍉 浏览器缓存


浏览器缓存就是浏览器将已经请求过的资源（如 HTML、CSS、JavaScript、图片等）**临时存储在本地**的一套机制


当浏览器发起请求时，它会遵循以下逻辑：

1. **检查强缓存**：如果强缓存命中且未过期，直接从本地获取资源，**不发请求到服务器**（状态码 200，显示 `from disk cache` 或 `from memory cache`）。
2. **检查协商缓存**：如果强缓存失效，浏览器会携带“缓存标记”发请求到服务器。服务器判断资源是否有更新。
    - **未更新**：返回状态码 **304 Not Modified**，通知浏览器继续使用本地副本。
    - **已更新**：返回状态码 **200 OK** 及最新的资源和缓存标识。

**1. 强缓存(不与服务器发生任何通信)**


**定义**：浏览器在请求资源时，先检查该资源的缓存是否还在“有效期”内。如果在，就直接使用缓存，**不与服务器发生任何通信**。


**`Cache-Control`**

- **`max-age=<seconds>`**：资源缓存的有效时长，单位是秒。这是相对时间，不受本地时间影响，是最常用的指令。
- **`no-store`**：**禁止一切缓存**，每次都要从服务器重新获取。
- **`no-cache`**：**这个名字有迷惑性！** 它不是“不缓存”，而是“强制进行协商缓存”。即浏览器会缓存资源，但在使用前必须向服务器验证其有效性。

**2. 协商缓存**


当强缓存失效（即 **`max-age`** 过期）后，浏览器并不会直接丢弃缓存，而是会携带一个“验证标识”向服务器发起请求，询问服务器：“我这里的这个缓存还能用吗？


验证是否需要缓存的两种协商方式：


1.**`Last-Modified`** **/** **`If-Modified-Since`** **（基于时间）**
2.**`ETag`** **/** **`If-None-Match`****（基于文件生成指纹）**


![1768737604098.png](https://r2.yisux.com/blog_img/1768737604098.png)


## 🍉 如何让缓存失效？


通常采用：

1. **Hash 命名**：给静态资源文件名加上 Hash（如 `app.a1b2c3.js`）。
2. **策略组合**：
    - **HTML**：设置 `no-cache`，确保每次都能拿到最新的入口文件。
    - **静态资源 (JS/CSS/Image)**：设置极长的强缓存（`max-age=31536000`），一旦文件更新，通过修改文件名（Hash 变动）来强制浏览器下载新资源。

## 🍉 箭头函数的特点 （很多都没有这样一个的特性）


**1. 没有** **`this`** **绑定（词法** **`this`****）**
这在处理回调函数（如 `setTimeout` 或事件监听）时非常有用，不再需要使用 `.bind(this)` 或特殊的 `that = this` 技巧。


**2. 不可以作为构造函数**
它没有 **`prototype`** 属性。


**3. 没有** **`arguments`** **对象**


箭头函数没有自己的 **`arguments`** 对象，没法传统的使用这个对象获取参数。


## 🍉 DIFF算法


问题：操作DOM开销很大


核心设计原则（三个假设）


为了实现高效比对，Vue 遵循了 Web 开发中的三个核心假设：

1. **同层比较（Level-by-level）**：算法只会在同层级之间进行比对，不会跨层级查找。如果一个节点在旧树的第二层，新树中移到了第三层，Vue 会直接销毁旧的并创建新的。
2. **相同标识（Key/Tag）**：如果两个节点的 `tag`（标签名）不同，或者 `key` 不同，Vue 会认为它们是完全不同的节点，直接替换。
3. **组件比对**：如果是相同类的组件，则继续递归执行其内部的 DIFF；如果是不同类的组件，则直接替换。

**Vue 2 的核心：双端 Diff**


Vue 2 采用的是一种**双端指针**的算法。它同时在旧子节点序列和新子节点序列的首尾各设置一个指针：`oldStart`, `oldEnd`, `newStart`, `newEnd`。


**Vue 3 的进化：快速 Diff**


Vue 3 借鉴了 `ivi` 和 `inferno` 算法，引入了 **Fast Diff“找规律”，**通过预处理和 LIS 算法，将 DOM 移动次数降到物理最低，并配合编译优化实现性能飞跃。


在 DIFF 过程中，`key` 是节点的“身份证”。

- **复用判断**：有了 `key`，Vue 才能准确判断“这个新节点其实就是刚才那个旧节点”，从而只更新属性而不销毁重建。
- **不建议使用 index 作为 key**：如果列表发生位移（如在中间插入一行），所有的 `index` 都会改变，导致 Vue 误以为所有节点都变了，引发大量无意义的销毁与重建，严重影响性能。

## 🍉Vue里的scoped


### 实现原理：


Vue 编译时会利用 **PostCSS** 对代码进行两步转换：

1. **HTML 标记**：为当前组件的所有 DOM 元素添加一个全局唯一的属性，例如 `data-v-f3f3eg9`。
2. **CSS 转换**：在选择器末尾添加对应的属性选择器。例如将 `.title` 编译为 `.title[data-v-f3f3eg9]`。

原理：`scoped` 是 标记HTML属性+选择器挂属性

- **浸透性（Deep Selectors）**：父组件的样式默认不会渗透到子组件。如果需要修改子组件内部样式，必须使用 `:deep()`、`::v-deep` 等深度选择器。（因为父组件的`scoped`样式，默认加了自己的唯一属性匹配不上子组件）
- **根节点泄漏**：父组件的 scoped 样式会同时作用于子组件的**根节点**，这是为了方便父组件对子组件进行布局调整。
- **心智负担低**：写代码时依然使用正常的类名，不需要特殊语法。

**Scoped** 像是给每个元素贴上“部门标签”，大家还在一个办公室，但通过标签区分。


## 🍉进程 vs 线程


| 对比项      | **进程（Process）**   | **线程（Thread）**   |
| -------- | ----------------- | ---------------- |
| **定义**   | 程序运行的最小单位         | CPU 调度的最小单位      |
| **资源**   | 拥有独立内存（代码段/堆/栈）   | 共享进程内存，只有独立栈和寄存器 |
| **开销**   | 创建/切换成本高          | 创建/切换成本低         |
| **安全性**  | 互不影响，更安全          | 共享内存，容易互相影响（需要锁） |
| **通信方式** | IPC（管道、消息队列、共享内存） | 共享内存即可，速度快       |
| **崩溃影响** | 一个进程挂了不影响其它进程     | 一个线程挂可能导致整个进程挂   |
| **适用场景** | 浏览器、数据库、独立服务      | 页面渲染、多任务并行计算     |


**进程是“独立房子”，线程是“房子里的房间”。**

- 每个房子拥有自己的电路、燃气、水（内存）。
- 房子（进程）之间互不影响。
- 房间（线程）共享同一个房子的资源。
- 线程之间更容易“抢水电”（竞争资源），需要“锁”。

### ❓1. 浏览器是多进程还是多线程？

- 是 **多进程 + 多线程**
- 每个标签页是独立进程
- 渲染器内部是多线程：JS 引擎线程、GUI 线程、定时器线程…

### ❓2. 为什么 JS 是单线程的？


因为 JS 要操作 DOM，如果多线程会造成并发修改的问题。


### ❓3. 为什么线程共享内存会出问题？


因为多个线程可能同时读写同一个变量 → 需要锁、原子操作。


plus:几个前端之外的计算机问题


**OSI 七层模型（从下到上）**


物数网传会表应 


**TCP/IP体系**


网络接口层  网络层 传输层 应用层


## 🍉 **Cookie** 


Cookie 本质上是由服务器发送并存储在浏览器上的一段 **文本信息**（通常大小限制在 4KB 左右）。

- **双向传递**：Cookie 最显著的特点是，只要在生效范围内，浏览器每次发起 HTTP 请求都会**自动携带**该域名下的所有有效 Cookie 到服务器。
- **无状态协议的补丁**：由于 HTTP 是无状态的，Cookie 常被用来充当“通行证”，让服务器识别当前请求来自哪个用户。

精准控制Cookie:


| **属性**                | **作用**   | **面试要点**                                                                 |
| --------------------- | -------- | ------------------------------------------------------------------------ |
| **Domain / Path**     | 限制作用域    | 决定了哪些 URL 可以访问该 Cookie。                                                  |
| **Expires / Max-Age** | 控制有效期    | `Expires` 是绝对时间，`Max-Age` 是相对秒数（优先级更高）。如果不设置，则为**会话 Cookie**，关闭浏览器即消失。   |
| **HttpOnly**          | **安全防御** | 设置后，**JS 无法通过** **`document.cookie`** **读取**。这是防御 XSS 攻击劫持 Cookie 的核心手段。 |
| **Secure**            | 传输加密     | 只允许在 **HTTPS** 协议下传输，防止明文监听。                                             |
| **SameSite**          | **跨站防御** | 限制第三方 Cookie，有效防御 **CSRF** 攻击。常见值有 `Strict`、`Lax`（默认）和 `None`。           |


### 对比


| **特性**   | **Cookie**      | **LocalStorage** | **SessionStorage** |
| -------- | --------------- | ---------------- | ------------------ |
| **容量**   | **~4KB** (极小)   | ~5MB (较大)        | ~5MB (较大)          |
| **数据传递** | **随 HTTP 请求发送** | 不参与服务器通信         | 不参与服务器通信           |
| **存续时间** | 可设置过期时间         | 永久保存，除非手动清除      | 窗口/标签页关闭即失效        |
| **主要用途** | 身份标识、Session 跟踪 | 存储大额非敏感数据        | 临时状态（如表单填写）        |


## 🍉 **Cookie 隐私**


一直不动cookie为啥一直有隐私问题，查阅资料整理下。


### 核心技术：“像素间谍”（Tracking Pixel）


在开始流程前，你需要知道一个关键工具：**1x1 像素图片**。
追踪者会在成千上万个网站的页面底部，埋下一段极小的代码，加载一张肉眼看不见的透明图片（来自追踪者的服务器 `spy.com`）。


### 第一阶段：植入“电子标签”


当你访问网站 A（比如：某鞋类电商）时：

1. **触发请求**：网页 A 加载了来自 `spy.com` 的透明图片。
2. **设置身份**：`spy.com` 的服务器收到请求。它看了一下你的浏览器，发现没有任何标识。
3. **分发 ID**：服务器在返回图片的同时，在 HTTP 响应头里塞了一个指令：`Set-Cookie: uid=12345`。
4. **建立档案**：服务器在数据库记下一笔：`用户 12345 正在浏览 A 网站的“耐克跑鞋”页面`。

### 第二阶段：跨站识别（间谍潜伏）


第二天，你访问了**网站 B（比如：一个健身资讯博客）**。这个网站也埋了 `spy.com` 的透明图片。

1. **自动上报**：浏览器解析到要加载 `spy.com` 的图片。它翻开“Cookie 存折”，发现有 `spy.com` 的记录。
2. **带上标签**：浏览器**自动**在请求头里加上：`Cookie: uid=12345`。
3. **身份匹配**：`spy.com` 的服务器收到请求，心里一笑：“嘿，12345 又来了。”
4. **丰富画像**：服务器更新档案：`用户 12345 正在浏览 B 网站的“膝盖康复指南”`。

### 第三阶段：收网与轰炸（精准营销）


当你访问网站 C（比如：微博或新闻门户）时：

1. **竞价广告**：网站 C 的广告位开始招标。`spy.com` 拿到了展示权。
2. **大数据拼图**：`spy.com` 调取后台数据：`uid=12345` = `想买跑鞋` + `膝盖疼`。
3. **精准打击**：它不给你推普通的衣服，而是精准推送：**“减震效果极好的护膝款跑鞋”**。

当带着 `uid=12345` 的 Cookie 去请求广告时后台智能调取合适的广告返回。


## 🍉 **Cookie 问题**


Cookie 的最大特点是**浏览器自动管理与发送**，这柄双刃剑直接导致了两个最著名的 Web 攻击场景：

- **XSS（跨站脚本攻击）—— 身份被窃取**：
由于 Cookie 默认可以通过 `document.cookie` 在 JavaScript 中访问，一旦页面被注入恶意脚本，黑客可以轻而易举地读取并盗走用户的登录凭证（Session ID）。
    - **对策**：必须设置 `HttpOnly` 属性，强制禁止脚本读取。
- **CSRF（跨站请求伪造）—— 身份被冒用**：
浏览器“只认域名”的特性，会导致你在访问恶意网站时，该网站发起的针对受信域名的请求会自动带上你的 Cookie。
    - **对策**：使用 `SameSite: Lax/Strict` 属性，或使用 CSRF Token 验证。

Cookie 会被附加在**每一个**符合条件的 HTTP 请求头（Request Header）中发送给服务器。

- **容量限制**：单个 Cookie 大小通常被限制在 **4KB** 以内，整个域名的 Cookie 数量也有上限（通常 20-50 个）。
- **无意义的带宽消耗**：如果我们将大量的非认证数据存放在 Cookie 中，那么在请求图片、CSS 等静态资源时，这些数据也会随之发送。
    - **影响**：对于高并发或移动端弱网环境，这会显著增加首屏渲染的延迟（RTT）。
    - **对策**：使用 **LocalStorage** 或 **IndexedDB** 存储非敏感数据；使用 **CDN 域名（非主域名）** 托管静态资源，以规避 Cookie 自动发送。

## 🍉 **Cookie 与跨域**


**cookie的问题在于“跨域嵌入（Cross-Origin Embedding）”** 与 **“Cookie 自动携带”**


### 🚫 严厉禁止：跨域“读取” (Cross-Origin Read)


 `XHR` 或 `Fetch`。

- **规则**：除非目标服务器明确表示（通过 **CORS** 协议）允许，否则你不能用 JS 去读另一个域名的返回内容。

### ✅ 默认允许：跨域“嵌入” (Cross-Origin Embed)


这是为了让开发者能方便地使用外部资源。

- **资源类型**：`<script>` (加载脚本)、`<img>` (显示图片)、`<link>` (加载 CSS)、`<iframe>` (嵌套页面)。

## **Promise 静态方法**


### **1.** **`Promise.resolve(value)`**


返回一个以给定值 **`value`** 成功的 Promise 对象。

- 如果 **`value`** 是一个普通值，它返回一个立即成功的 Promise。
- 如果 **`value`** 是一个 Promise 对象，它直接返回这个 Promise。
- 如果 **`value`** 是一个 **`thenable`** 对象（即有 **`then`** 方法的对象），它会将这个对象“包装”成一个真正的 Promise。

```typescript
const p1 = Promise.resolve('成功');
const p2 = Promise.resolve(p1);

console.log(p1 === p2); // true, 如果传入的是 Promise，则直接返回

const thenable = {
  then: (resolve) => resolve('我是一个 thenable')
};
const p3 = Promise.resolve(thenable);
p3.then(console.log); // 输出: 我是一个 thenable
```


### **2.** **`Promise.reject(reason)`**


返回一个以给定原因 **`reason`** 失败的 Promise 对象。



```typescript
const p = Promise.reject(new Error('失败了'));
p.catch(error => console.error(error.message)); // 输出: 失败了
```


### 成功型promise


### **3.** **`Promise.all(iterable)`**

- **当所有 Promise 都成功时**，新的 Promise 才会成功。其成功结果是一个数组，包含了所有 Promise 的成功结果，顺序与传入的 Promise 顺序一致。
- **只要有任何一个 Promise 失败**，新的 Promise 就会立即失败，其失败原因是第一个失败的 Promise 的失败原因。

```typescript
const p1 = Promise.resolve(3);
const p2 = new Promise(resolve => setTimeout(() => resolve('foo'), 1000));
const p3 = Promise.resolve(42);

Promise.all([p1, p2, p3]).then(values => {
  console.log(values); // 1秒后输出: [3, 'foo', 42]
});

const p4 = Promise.reject('失败了');
Promise.all([p1, p4, p3]).catch(error => {
  console.error(error); // 立即输出: 失败了
});
```


### **6.** **`Promise.any(iterable)`**


接收一个 Promise 的可迭代对象，返回一个**新的 Promise**。

- 一旦**任何一个**传入的 Promise 成功，新的 Promise 就会立即成功，其结果是那个成功的 Promise 的结果。
- 如果**所有**传入的 Promise 都失败了，新的 Promise 才会失败，其失败原因是一个 **`AggregateError`** 对象，它包含了所有 Promise 的失败原因。

```typescript
const p1 = Promise.reject(new Error('失败 1'));
const p2 = Promise.reject(new Error('失败 2'));
const p3 = Promise.resolve('成功 3');

Promise.any([p1, p2, p3]).then(value => {
  console.log(value); // 输出: '成功 3'
});

Promise.any([p1, p2]).catch(error => {
  console.error(error); // 输出: AggregateError: All promises were rejected
  console.error(error.errors); // 输出: [Error: 失败 1, Error: 失败 2]
});
```


### 不管成不成功的


### **4.** **`Promise.race(iterable)`**


接收一个 Promise 的可迭代对象，返回一个**新的 Promise**。

- 这个新的 Promise 会在**任何一个**传入的 Promise 完成（成功或失败）时，立即采用其状态和结果。就像一场赛跑，谁先完成就听谁的。

### **5.** **`Promise.allSettled(iterable)`**


接收一个 Promise 的可迭代对象，返回一个**新的 Promise**。

- 这个新的 Promise 会等到**所有**传入的 Promise 都完成（无论成功还是失败）后才会成功。
- 其成功结果是一个数组，每个对象都对应一个传入的 Promise，并描述了其最终状态。
    - **`{ status: 'fulfilled', value: ... }`** 表示成功。
    - **`{ status: 'rejected', reason: ... }`** 表示失败。

这对于需要知道所有异步操作最终结果，而不关心是否有失败的场景非常有用。


## 🍉  水平垂直居中方法


1.**flexbox方法**


将父容器设置为 Flex 布局，然后利用 **`justify-content`** 和 **`align-items`** 属性分别控制主轴和交叉轴的对齐方式。

2.**Grid 方法**


将父容器设置为 Grid 布局，使用 **`place-items`** 属性一步到位实现居中。



3.**Position + Transform 方法**

1. 将父容器设为相对定位。
2. 将子元素设为绝对定位，并使用 **`top: 50%`** 和 **`left: 50%`** 使其左上角移动到父容器的中心。
3. 使用 **`transform: translate(-50%, -50%)`** 将子元素向左和向上回拉自身宽度和高度的 50%，从而实现中心对齐。

4.**Position + Margin 方法**


**核心思想：** 与 **`transform`** 方法类似，但使用负 **`margin`** 来代替 **`transform`** 进行偏移



5.**Table-cell 方法（特殊场景）**


将父容器模拟成表格单元格（**`display: table-cell`**），然后利用表格的 **`vertical-align: middle`** 属性来实现垂直居中，再配合 **`text-align: center`** 实现水平居中。


## 
🍉性能优化：**浏览器渲染一帧都做了什么？**


**帧率** 就是每秒钟渲染的帧数，单位是 **fps (Frames Per Second)**。

- **60fps** 是目前业界公认的“流畅”标准。它意味着浏览器需要在 **1000ms / 60 ≈ 16.67ms** 内完成**所有**工作来生成一帧。
- 如果生成一帧的时间超过了 16.67ms，比如 33ms，那么帧率就会下降到 30fps，用户就会感觉到**卡顿（浏览器卡顿表现）**。

**核心目标：** 保证每一帧的渲染时间都控制在 **16.67ms** 以内，以达到流畅的 60fps 体验。


**优化策略：如何保证流畅的 60fps？**


优化的核心思想是：**避免昂贵的 Layout 和 Paint，尽量只触发廉价的 Composite。**


**1. 使用** **`requestAnimationFrame`** **(rAF)**


永远不要用 **`setTimeout`** 或 **`setInterval`** 来做视觉动画。**`rAF`** 是浏览器专门为动画提供的 API，它会在每一帧开始时调用你的回调函数，保证你的动画逻辑与浏览器的刷新率同步，避免掉帧和卡顿。


```javascript
function animate() {
  // 在这里执行动画逻辑
  element.style.transform = 'translateX(' + x + 'px)';
  x += 1;

  // 请求下一帧继续执行
  requestAnimationFrame(animate); 
}

requestAnimationFrame(animate);
```


**2. 批量 DOM 读写**


解决“布局抖动”的关键。**先一次性读完所有需要的布局信息，再一次性写入所有样式更改。**


**3. 使用** **`transform`** **和** **`opacity`** **实现动画**


这是现代前端性能优化的**黄金法则**。

- **`transform`**（如 **`translate`**, **`scale`**, **`rotate`**）
- **`opacity`**

这两个属性有一个巨大的优势：**它们的改变只会触发 Composite（合成）阶段，而不会触发 Layout 和 Paint。**


浏览器会为这些元素创建一个独立的图层，交由 GPU 直接处理，这个过程极快。因此，用 **`transform: translateX()`** 来移动元素，远比修改 **`left`** 属性性能要好得多。


**4. 使用** **`will-change`** **或** **`transform: translateZ(0)`** **提示创建新图层**


如果你知道某个元素将要被频繁地独立动画（如一个弹窗、一个旋转的图标），你可以使用 CSS 属性提前告知浏览器，让它为这个元素创建一个新的图层，从而优化合成性能。


**+RAF原理**


RAF是一个类似`settimeout/settimeinterval`的定时器 需要传入一个回调函数 时间默认设置一帧的时间,默认把他想成一个帧定时器就可以


```javascript
function func(){
            console.log('animation frame')
            requestAnimationFrame(func)
        }
    func()
```


会每一帧时间输出


## 🍉 浏览器渲染过程


1. 构建 DOM 树 (Parsing HTML)


当浏览器收到 HTML 响应后，渲染引擎的 HTML 解析器开始工作。


2.构建 CSSOM 树 (Parsing CSS)


在解析 HTML 时，如果遇到 `<link>` 或 `<style>`，解析器会暂停或并行下载 CSS 并构建 **CSSOM (CSS Object Model)**。


3. 生成渲染树 (Render Tree)


将 DOM 树和 CSSOM 树合并成 **Render Tree**。


4. **布局**/回流 (Layout / Reflow)


有了渲染树后，浏览器需要计算每个节点在屏幕上的确切**几何位置和大小**。

- **坐标计算**：从根节点开始，计算元素相对于视口（Viewport）的位置。
- **触发频率**：任何改变元素几何属性的操作（如修改宽高、窗口缩放）都会触发回流。

5. **分层与绘制** (Painting / Repaint)


浏览器会将页面拆分为多个**图层（Layers）**。


6. 合成 (Compositing)


这是最后一步，由 **Compositor Thread（合成器线程）** 负责


改变 `transform` 或 `opacity` 属性时，浏览器可以直接在合成线程完成，不需要经过布局和绘制，这被称为 **GPU 加速**。


| **概念**           | **触发条件**             | **性能开销**                   |
| ---------------- | -------------------- | -------------------------- |
| **回流 (Reflow)**  | 几何属性变化（宽高、位置、增删 DOM） | **极高**（涉及几何计算，会影响子元素和后续元素） |
| **重绘 (Repaint)** | 样式属性变化（颜色、阴影、背景色）    | **中等**（不影响布局，直接重新填充像素）     |


![1768741880386.png](https://r2.yisux.com/blog_img/1768741880386.png)


## 🍉 **事件委托**


 事件委托是一种利用事件冒泡机制，将事件监听器添加到父元素上，而不是其每个子元素上的技术


**1. 性能优化（减少内存占用）**


对于需要处理大量相似元素的页面，事件委托能极大地**减少内存消耗**和**提高页面初始化速度**。

**2. 动态元素支持（灵活性和可维护性）**


事件委托让你的代码对 DOM 的动态变化“免疫”，大大提高了代码的**灵活性和可维护性**。

**3. 代码简洁和集中管理**


所有子元素的事件处理逻辑都集中在父元素的那个监听函数中。这使得代码结构更清晰，更容易统一管理和修改。


**实现事件委托**


实现事件委托的关键在于两点：**利用事件冒泡** 和 **使用** **`event.target`**


**`event.target`**：指向**真正触发事件的那个元素**（比如被点击的那个 **`li`**）
**`event.currentTarget`**：指向**绑定了事件监听器的那个元素**（比如 **`ul`**）


## 🍉 CSS **伪类与伪元素**


伪类是 **基于已有 DOM 元素**，但状态变化了。


伪类表示元素处在一种特殊“状态”，例如：

- 悬停状态
- 被点击状态
- 第几个子元素
- 表单验证状态

👉 **语法：一个冒号** **`:`**


常见示例：


```css
a:hover { color: red; }      /* 鼠标悬停状态 */
input:focus { border: blue;} /* 聚焦状态 */
li:first-child { }           /* 第一个子元素 */
tr:nth-child(odd) { }        /* 奇数行 */
```



伪元素会 **生成一段内容/结构**, 但不在 HTML 中出现。


伪元素用于 **创建新的虚拟节点** 或 **选中内部结构**，例如：

- 元素的第一行
- 元素的第一个字母
- 内容前后插入文本

👉 **语法：两个冒号** **`::`**


```css
p::first-line { }    /* 第一行 */
p::first-letter { }  /* 第一个字 */
::selection { }      /* 被选中文本 */
```



最常用是 `::before` 和 `::after`


| 类别                     | 描述                                  |
| ---------------------- | ----------------------------------- |
| **伪类 pseudo-class**    | 选择元素的**状态** (已存在的元素)                |
| **伪元素 pseudo-element** | **制造虚拟元素** 或 **选中元素的一部分** (不存在的子结构) |


## 🍉 grid两轴布局


**CSS Grid 布局中的“显式网格”和“隐式网格”**


显式网格是你使用 **`grid-template-*`** 属性**明确定义**的网格结构。它构成了你布局的主要框架。
隐式网格是当网格项目**超出了**你显式定义的范围时，浏览器**自动创建**的额外轨道（行或列）。

这有个例子比较清楚：


```html
<div class="container">
  <div class="item item-1">1</div>
  <div class="item item-2">2</div>
  <div class="item item-3">3</div>
  <div class="item item-4">4</div>
  <!-- 多出来的第5个项目 -->
  <div class="item item-5">5</div>
</div>
```


对应grid:


```css
.container {
        display: grid;
        grid-template-columns: 100px 100px;
        grid-template-rows: 200px 200px;
        gap: 20px;
        text-align: center;
      }
 .item {
        background: rgb(211, 119, 119);
      }
```


本来是看起来grid布了一个 2x2 的布局 但是很明显多了一个5 这时候就会自动产生额外轨道


```css
.container {
        display: grid;
        grid-template-columns: 100px 100px;
        grid-template-rows: 200px 200px;
        gap: 20px;
        grid-auto-rows: 160px; /*add only for 5*/
        text-align: center;
      }
```


这时候 `auto` 属性起作用了 可以独自控制这个多出来的元素


| 方面        | 显式网格                                                               | 隐式网格                                              |
| --------- | ------------------------------------------------------------------ | ------------------------------------------------- |
| **定义方式**  | **有意定义**，使用 `grid-template-*` 属性。                                  | **自动创建**，当内容溢出显式网格时。                              |
| **使用属性**  | `grid-template-columns | grid-template-rows | grid-template-areas` | `grid-auto-columns|grid-auto-rows|grid-auto-flow` |
| **创建时机**  | CSS 解析时，作为布局的**主要骨架**。                                             | 运行时，作为**内容溢出的补充**。                                |
| **目的/作用** | 构建稳定、可预测的布局结构。                                                     | 提高布局的灵活性，处理动态或未知数量的内容。                            |
| **可预测性**  | **高**。你完全知道网格的样子。                                                  | **较低**。依赖于内容，但可以通过 `grid-auto-*` 控制其行为。           |


**Grid高度自定义的轴线模式**


![1_diagram_numbered_grid_lines.png](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Guides/Grid_layout/Basic_concepts/1_diagram_numbered_grid_lines.png)


通过grid可以对每一个item进行高度自定义的布局 一般通过轴线实现


比如原始这个图的grid可能是


```css
.container {
        display: grid;
        grid-template-columns: 100px 100px 100px;
        grid-template-rows: 60px 60px 60px;
        gap: 10px;
      }
```


如果我想要对one进行独占一行的布局怎么办呢 在grid实现较为简单 通过控制div的列向左轴位和右轴位来实现


```css
.item-1 {
        grid-column-start: 1;
        grid-column-end: 4;
 }
 //==
 .item-1 {
        grid-column:1/4;
 }
```


通过自定义占据轴线可以很好的进行方块化布局 **Grid的魔法我觉得在于两轴+轴线设计**


**Grid实现的看起来不可能的例子 这边我原以为必须复杂的盒模型以及float实现没想到grid不需要动html就可以**


![grid1.png](https://ife.baidu.com/assets/img/cssimg/grid1.png)


```html
<style>
      dl {
        display: grid;
        grid-template-columns: 100px 200px;
      }
      dd {
        margin: 0;
      }
      dt:nth-of-type(1) {
        font-weight: bold;
        grid-row: 1/4;
      }
      dt:nth-of-type(2) {
        font-weight: bold;
        grid-row: 4/6;
      }
      dt:nth-of-type(3) {
        font-weight: bold;
        grid-row: 6/9;
      }
    </style>
  </head>
  <body>
    <dl>
      <dt>恐龙类</dt>
      <dd>尹氏芦沟龙</dd>
      <dd>破碎中国虚骨龙</dd>
      <dd>原始川东虚骨龙</dd>
      <dt>鲨鱼类</dt>
      <dd>六鳃鲨目</dd>
      <dd>鼠鲨目</dd>
      <dt>鸟类</dt>
      <dd>雁形目</dd>
      <dd>雨燕目</dd>
      <dd>夜鹰目</dd>
    </dl>
  </body>
```


## 🍉 瀑布流布局（小红书布局）


本质是宽度固定而高度不固定的卡片垂直布局


1.传统


`multi-column`实现 `瀑布流`主要依赖以下几个属性：

- `column-count`: 设置共有几列
- `column-width`: 设置每列宽度，列数由 `总宽度`与 `每列宽度`计算得出
- `column-gap`: 设置列与列之间的间距

2.grid布局


需要根据图片高度手动设置栅格网格布局的占据比例


目前使用 CSS Grid 做瀑布流，一定需要手动（或 JS 自动）设置元素跨多少行！


3.flex布局


先手动设置3列在列里面竖向布局


再让每一列是一个纵向排列的 flex 容器。


## 🍉变量提升


**在代码执行前，JavaScript 引擎会先进行一个“编译”阶段，在这个阶段，它会找到所有的变量声明（****`var`****）和函数声明（****`function`****），并将它们“提升”到其所在作用域的顶部。**

1. **只有声明被提升**：变量的赋值操作（初始化）不会被提升。
2. **提升到作用域顶部**：
    - **`var`** 声明的变量会被提升到**函数作用域**的顶部。
    - **`let`** 和 **`const`** 声明的变量会被提升到**块级作用域**（**`{...}`**）的顶部，但它们处于一个“暂时性死区”，无法访问。

### **不同类型声明的提升行为**


### **1.** **`var`** **的提升（经典提升 数值不提升）**


```javascript
function myFunction() {
  console.log(myVar); // 输出 undefined，而不是报错
  var myVar = 5;
  console.log(myVar); // 输出 5
}

myFunction();
```


### **2.** **`function`** **的提升（函数声明）**


函数声明的提升非常“完整”，整个函数体都会被提升到作用域的顶部。这意味着你可以在函数声明之前调用它。


```javascript
function sayHello(name) { // 整个函数体被提升
  console.log("Hello, " + name);
}

sayHello("World"); // 调用在声明之后执行
```


**注意：** 函数表达式（如 **`var myFunc = function() {}`**）的规则和 **`var`** 变量提升一样，只有变量声明 **`var myFunc`** 被提升，其值 **`undefined`**，函数体本身不会被提升。




```javascript
myFunc(); // TypeError: myFunc is not a function

var myFunc = function() {
  console.log("This will not be hoisted.");
};
```


### **3.** **`let`** **和** **`const`** **的提升（现代提升）**


**`let`** 和 **`const`** 是 ES6 引入的，它们也**存在提升**，但行为与 **`var`** 完全不同。

- 它们的声明被提升到块级作用域（**`{...}`**）的顶部。
- 但是，它们不会被初始化为 **`undefined`**。
- 从作用域开始到声明语句之间的这段区域，被称为**暂时性死区**。在这个区域内访问这些变量会导致 **`ReferenceError`**。

这种机制是为了强制开发者养成良好的编码习惯：**先声明，后使用**。


**总结：** **忘记** **`var`** **的存在，拥抱** **`let`** **和** **`const`**。这不仅能让你完全规避变量提升带来的 **`undefined`** 问题，还能让你写出更安全、更易于维护的现代 JavaScript 代码。



## 🍉**JS 转整数的方法**



**1.** **`parseInt()`** **- 最常用、最推荐**


**从左到右解析**：它会逐个字符解析字符串，直到遇到一个无法解析的字符为止，然后返回已解析的部分。


无四舍五入直接返回整数


**2.** **`Math`** **对象的取整方法**


**a.** **`Math.floor()`** **- 向下取整**


```javascript
Math.floor(4.9);   // 4
Math.floor(4.1);   // 4
Math.floor(-4.1);  // -5 (比 -4.1 小的最大整数是 -5)
Math.floor(-4.9);  // -5
```


**b.** **`Math.ceil()`** **- 向上取整**


**c.** **`Math.round()`** **- 四舍五入**


**d.** **`Math.trunc()`** **- 直接截断小数部分 (ES6)**


## 🍉 js的数学运算有哪些坑


| 坑点                | 现象                                  | 解决方案 / 最佳实践                                             |
| ----------------- | ----------------------------------- | ------------------------------------------------------- |
| **浮点数精度**         | `0.1 + 0.2 !== 0.3`                 | 使用 `Number.EPSILON` 进行容差比较，或转为整数运算，或使用 `decimal.js` 等库。 |
| **`+`** **运算符**   | `'5' + 5` 结果为 `"55"`                | 使用 `Number()` 或 `parseInt()` 进行显式类型转换。                  |
| **`NaN`** **的特性** | `NaN === NaN` 结果为 `false`           | 使用 `Number.isNaN()` 来判断。                                |
| **`Infinity`**    | `1 / 0` 结果为 `Infinity`              | 使用 `Number.isFinite()` 来检查是否为有限数字。                      |
| **整数溢出**          | `Number.MAX_SAFE_INTEGER + 2` 结果不正确 | 对于超出安全范围的整数，使用 `BigInt` 类型。                             |
| **`parseInt`**    | `parseInt('010')` 可能有歧义             | **总是提供第二个参数** **`radix`**，如 `parseInt(str, 10)`。        |


## 🍉 js字符转数组 数组转字符串


| 转换方向         | 推荐方法                           | 说明                                 | 注意事项                          |
| ------------ | ------------------------------ | ---------------------------------- | ----------------------------- |
| **字符串 → 数组** | `Array.from(str)` 或 `[...str]` | 现代、简洁，能正确处理所有 Unicode 字符（如 Emoji）。 | ES6+ 环境。                      |
|              | `str.split('')`                | 经典方法，兼容性好。                         | 无法正确处理复合 Unicode 字符。          |
|              | `str.split(separator)`         | 当你需要按特定分隔符（如逗号、空格）分割时，这是唯一选择。      | -                             |
| **数组 → 字符串** | `arr.join(separator)`          | 最灵活、最常用的方法。可以自定义任意分隔符。             | -                             |
|              | `arr.toString()`               | 简单快捷，但只能使用逗号作为分隔符。                 | 不够灵活，主要用于调试。                  |
|              | `JSON.stringify(arr)`          | 用于生成标准的 JSON 格式字符串，适合数据传输和存储。      | 生成的字符串包含 `[]` 和 `""`，不是简单的拼接。 |


## 🍉  js循环体


| 循环类型             | 主要用途        | 遍历内容  | 推荐场景                     |
| ---------------- | ----------- | ----- | ------------------------ |
| **`for`**        | 已知循环次数      | 计数器索引 | 传统数组遍历，需要索引时             |
| **`while`**      | 未知循环次数，基于条件 | 条件判断  | 游戏循环、读取文件直到末尾            |
| **`do...while`** | 至少执行一次      | 条件判断  | 用户输入验证（至少问一次）            |
| **`for...in`**   | 遍历对象属性      | 对象的键  | 遍历普通对象的属性                |
| **`for...of`**   | 遍历可迭代对象     | 集合的值  | **遍历数组、字符串、Map、Set 的首选** |


```javascript
for (const key in object) {
    // 循环体
}
const person = {
    name: 'Alice',
    age: 30,
    job: 'Engineer'
};

for (const key in person) {
    console.log(`${key}: ${person[key]}`);
}
// 输出:
// name: Alice
// age: 30
// job: Engineer

for (const value of iterable) {
    // 循环体
}
// 遍历数组 (推荐)
const fruits = ['apple', 'banana', 'orange'];
for (const fruit of fruits) {
    console.log(fruit);
}
// 输出: apple, banana, orange

// 遍历字符串
const str = "hello";
for (const char of str) {
    console.log(char);
}
// 输出: h, e, l, l, o
```


## 🍉 dom拿值


```javascript
<input type="text" class="name" onchange="changeName(this)" />

<script>
function changeName(el) {
  console.log(el.value);
}
</script>
```


```javascript
<input type="text" class="name" onchange="changeName(event)" />

<script>
function changeName(e) {
  console.log(e.target.value);
}
</script>
```


## 🍉**可选链 ?.** 


ES2020特性


解决了在 JavaScript 中访问一长串对象属性时必须进行多次 null 检查的问题


```javascript
obj = {
  prop1: {
    prop2: {
      someProp: "value",
    },
  },
};
传统的:obj.prop1 && obj.prop1.prop2 && obj.prop1.prop2.someProp;
现代的:obj.prop1?.prop2?.someProp;
```


如果其中一个属性是 null 或 undefined，则可选链?.将停止读取您要求它读取的属性并返回 undefined.


**空值合并 ??**


希望在变量为 null 或 undefined 的情况下应用默认值


```javascript
let amount = null;
amount = amount ?? 1; // => 1,符合预期 ✅

amount = 0;
amount = amount ?? 1; // => 0,符合预期 ✅

amount = "";
amount = amount ?? 1; // => '',符合预期 ✅
```


一个结合的例子


```javascript
let vip_customer_1 = {
        name: "Carl",
        vip: {
          num: "U-1001",
          country: "USA",
        },
      };

      let vip_customer_2 = {
        name: "Carl",
        vip: {
          num: "C-1001",
        },
      };

      let customer = {
        name: "Jennie",
      };

      /**
       * @param {object} customer
       * @param {object} [customer.vip]
       * @param {last} [customer.vip.country]
       */
      const isVip = (cust) => {
        return cust.vip?.num ?? "undefined";
      };

      //用例
      console.log(isVip(vip_customer_1)); // => 'U-1001'
      console.log(isVip(vip_customer_2)); // => 'C-1002'
      console.log(isVip(customer)); //  => 'undefined'
```


## 🍉 **页面生命周期**


HTML 页面的生命周期包含三个重要事件：

- `DOMContentLoaded` —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 `<img>` 和样式表之类的外部资源可能尚未加载完成。
- `load` —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。
- `beforeunload/unload` —— 当用户正在离开页面时。
- 当 DOM 准备就绪时，`document` 上的 `DOMContentLoaded` 事件就会被触发。在这个阶段，我们可以将 JavaScript 应用于元素。
    - 诸如 `<script>...</script>` 或 `<script src="..."></script>` 之类的脚本会阻塞 `DOMContentLoaded`，浏览器将等待它们执行结束。
    - 图片和其他资源仍然可以继续被加载。
- 当页面和所有资源都加载完成时，`window` 上的 `load` 事件就会被触发。我们很少使用它，因为通常无需等待那么长时间。
- 当用户想要离开页面时，`window` 上的 `beforeunload` 事件就会被触发。如果我们取消这个事件，浏览器就会询问我们是否真的要离开（例如，我们有未保存的更改）。
- 当用户最终离开时，`window` 上的 `unload` 事件就会被触发。在处理程序中，我们只能执行不涉及延迟或询问用户的简单操作。正是由于这个限制，它很少被使用。我们可以使用 `navigator.sendBeacon` 来发送网络请求。
- `document.readyState` 是文档的当前状态，可以在 `readystatechange` 事件中跟踪状态更改：
    - `loading` —— 文档正在被加载。
    - `interactive` —— 文档已被解析完成，与 `DOMContentLoaded` 几乎同时发生，但是在 `DOMContentLoaded` 之前发生。
    - `complete` —— 文档和资源均已加载完成，与 `window.onload` 几乎同时发生，但是在 `window.onload` 之前发生。

## 🍉 BOM


比如navigator看浏览器信息，screen看浏览器可视窗口，location看浏览器url,history看浏览器记录这些都是BOM


## 🍉 **requestAnimationFrame**


解决定时器做动画卡顿的问题


`requestAnimationFrame`能够做到，精准严格的卡住显示器刷新的时间，比如普通显示器`60HZ`它会自动对应`17ms`执行一次，高级显示器`120HZ`，它会自动对应`9ms`执行一次。


使用方法


```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .box {
        width: 50px;
        height: 50px;
        background-color: crimson;
        position: absolute; /* 需要定位才能移动 */
        left: 0;
      }
    </style>
  </head>
  <body>
    <div class="box"></div>
    <script>
      const box = document.querySelector(".box");
      let pos = 0;
      function animate() {
        pos++;
        box.style.left = pos + "px";
        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);
    </script>
  </body>
</html>
```


## 🍉 优雅的 map and set


```javascript
// 使用 Set 去除数组的重复项
function dedupe(array) {
  // 1. new Set(array) 会创建一个 Set 对象，自动去除所有重复值。
  // 2. [...new Set(array)] 使用展开语法(...)将 Set 对象转换回数组。
  return [...new Set(array)];
}

// 利用 Set 实现并集
function union(arr1, arr2) {
  // 1. 使用展开语法将两个集合/数组合并成一个新数组。
  // 2. new Set() 会自动处理这个合并后数组中的重复项，从而得到并集。
  return new Set([...arr1, ...arr2]);
}

// 利用 Set 实现交集
function intersect(arr1, arr2) {
  // 1. 将第二个集合/数组转换为 Set，以便利用其高效的 has() 方法进行查找。
  const set2 = new Set(arr2);
  // 2. 遍历第一个集合/数组，使用 filter() 筛选出那些也存在于 set2 中的元素。
  // 3. 将筛选结果（一个数组）再转换成 Set。
  return new Set([...arr1].filter(item => set2.has(item)));
}

// 利用 Set 实现差集
function difference(arr1, arr2) {
  // 1. 将第二个集合/数组转换为 Set，以便利用其高效的 has() 方法进行查找。
  const set2 = new Set(arr2);
  // 2. 遍历第一个集合/数组，使用 filter() 筛选出那些不存在于 set2 中的元素。
  // 3. 将筛选结果（一个数组）再转换成 Set。
  return new Set([...arr1].filter(item => !set2.has(item)));
}


// 测试用例
console.log(dedupe([1, 1, 2, 3])); // [1, 2, 3]

let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

console.log(union(a, b)); // -> Set {1, 2, 3, 4}
console.log(intersect(a, b)); // -> Set {2, 3}
console.log(difference(a, b)); // ->  Set {1}
```


```javascript
// 封装一个函数实现 Map 转为 数组
function strMapToArray(map) {
  // 使用展开语法(...)可以将 Map 对象转换为一个由 [key, value] 对组成的数组。
  // 这等同于 Array.from(map.entries())
  return [...map];
}

// 封装一个函数实现 数组 转为 Map
function arrayTostrMap(arr) {
  // Map 构造函数可以直接接受一个由 [key, value] 对组成的数组来创建 Map 实例。
  return new Map(arr);
}

// 封装一个函数实现 Map 转为 对象
function strMapToObj(strMap) {
  let obj = Object.create(null);
  // 遍历 Map 中的每一个键值对
  for (let [k, v] of strMap) {
    // 将键值对设置到新对象上
    // 注意：如果 Map 的键不是字符串，它会被自动转换为字符串。
    obj[k] = v;
  }
  return obj;
}

// 封装一个函数实现 对象转为 Map
function objToStrMap(obj) {
  // Map 构造函数可以接受 Object.entries() 的返回值
  // Object.entries(obj) 会返回一个由对象自身可枚举属性的 [key, value] 对组成的数组
  return new Map(Object.entries(obj));
}

// 封装一个函数实现 Map 转为 JSON
function strMapToJson(strMap) {
  // JSON.stringify 不能直接处理 Map，需要先将 Map 转换为普通对象
  return JSON.stringify(strMapToObj(strMap));
}

// 封装一个函数实现 JSON 转为 Map
function jsonToStrMap(jsonStr) {
  // 先将 JSON 字符串解析为对象，再将对象转换为 Map
  return objToStrMap(JSON.parse(jsonStr));
}


// --- 测试用例 ---

// 测试用例一: 数组 -> Map
let arr = [
  [true, 7],
  [{ foo: 3 }, ["abc"]],
];
console.log(arrayTostrMap(arr)); // -> Map {true => 7, Object {foo: 3} => ["abc"]}

// 测试用例二: Map -> 对象
const myMapForObj = new Map().set("yes", true).set("no", false);
console.log(strMapToObj(myMapForObj)); // -> { yes: true, no: false }

// 测试用例三: 对象 -> Map
console.log(objToStrMap({ yes: true, no: false })); // -> Map {"yes" => true, "no" => false}

// 测试用例四: Map -> JSON
let myMapForJson = new Map().set("yes", true).set("no", false);
console.log(strMapToJson(myMapForJson)); // -> '{"yes":true,"no":false}'

// 测试用例五: JSON -> Map
console.log(jsonToStrMap('{"yes": true, "no": false}')); //-> Map {'yes' => true, 'no' => false}

// 测试用例六: Map -> 数组
const myMapForArray = new Map().set(true, 7).set({ foo: 3 }, ["abc"]);
console.log(strMapToArray(myMapForArray)); //-> [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]
```


## 🍉 **Map 与 Object 的区别及应用场景**


**核心区别**


| 特性           | `Map`                                                                           | `Object`                                                                                            |
| ------------ | ------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |
| **键的类型**     | **任意类型** (包括对象、函数、原始类型等)                                                        | **只能是** **`String`** **或** **`Symbol`**                                                             |
| **默认键**      | **没有默认键**，是一个干净的集合                                                              | **有原型链**，会继承 `Object.prototype` 上的默认键 (如 `toString`, `hasOwnProperty`)                              |
| **大小/长度**    | 通过 `.size` 属性直接获取，性能好                                                           | 需要通过 `Object.keys(obj).length` 计算，性能较差                                                              |
| **性能**       | 在**频繁增删键值对**的场景下性能更优                                                            | 在简单场景下性能很好，但键值对非常多时，增删性能可能不如 `Map`                                                                  |
| **迭代**       | **天生可迭代**，默认按插入顺序迭代。迭代方式多样 (`for...of`, `forEach`, `keys`, `values`, `entries`) | **不是天生可迭代** (ES6前)，需要通过 `Object.keys()`, `Object.values()`, `Object.entries()` 转换。`for...in` 会遍历原型链 |
| **顺序**       | **保证插入顺序**                                                                      | ES6 后，对于 String 和 Symbol 键会保证插入顺序，但总体不如 `Map` 直观和可靠                                                 |
| **JSON 序列化** | **不能直接序列化**。需要先转为 Object 或数组。                                                   | **原生支持** `JSON.stringify()` 和 `JSON.parse()`                                                        |


**什么时候使用** **`Map`****？**

1. **键不是字符串时**：这是 **`Map`** 最核心的优势。例如，你需要将一个 DOM 元素与它的相关数据关联起来。
2. **需要频繁增删键值对**：如果你的数据结构是动态的，需要频繁地添加和删除成员，**`Map`** 的性能通常更好。
3. **需要保证键值对的插入顺序**：当你遍历集合时，元素的顺序必须与它们被添加的顺序一致。
4. **需要一个“干净”的键值对集合**：当你不希望任何来自原型链的默认键（如 **`toString`**）干扰你的数据时。
- **`Object`** **vs** **`Map`**：如果你的键是字符串，并且需要与 JSON 交互，用 **`Object`**。如果你的键是任意类型，或者需要频繁增删和保证顺序，用 **`Map`**。
- **`Array`** **vs** **`Set`**：如果你需要有序的、可重复的、能通过索引访问的列表，用 **`Array`**。如果你需要一个没有重复值的集合，并且需要高效地进行成员检查，用 **`Set`**。

## 🍉 深拷贝浅拷贝


浅拷贝常用方法


### **(1) 解构**


```javascript
const copy = { ...obj };
const arrCopy = [...arr];
```


### **(2) Object.assign**


```javascript
const copy =Object.assign({}, obj);
```


### **(3) Array.prototype.slice / concat**


```javascript
const arrCopy1 = arr.slice();
const arrCopy2 = arr.concat();
```


深拷贝


### **(1) structuredClone（现代浏览器推荐）**


```javascript
const newObj =structuredClone(obj);
```


✓ 严格意义的深拷贝


---


### **(2) JSON 序列化**


```javascript
const newObj =JSON.parse(JSON.stringify(obj));
```


缺点：


❌ 丢 `undefined`在 JSON 里是不合法的，所以会被删掉


❌ 丢函数 `function`也不能序列化


❌ 丢 `Symbol`Symbol 也不合法


❌ 不能处理循环引用


❌ `Date` 变字符串


❌ `Map/Set` 丢失


---


### **(3) 递归手写深拷贝（面试常考）**


```javascript
functiondeepClone(obj) {
if (obj ===null ||typeof obj !=='object')return obj;

const result =Array.isArray(obj) ? [] : {};

for (const keyin obj) {
    result[key] =deepClone(obj[key]);
  }

return result;
}
```


问题：不支持循环引用、Map、Set 等


---


### **(4) Lodash** **`_.cloneDeep`**


最稳健的库方案：


```javascript
const _ =require('lodash');
const newObj = _.cloneDeep(obj);
```


## 🍉 **`transition`**、**`animation`** 和 **`requestAnimationFrame`** (RAF) 


**状态变化 → 用** **`transition`**


**自己动、循环动、自动播放 → 用** **`animation`**


**你要自己算每一帧 → 用** **`requestAnimationFrame`****（raf）**


### 
什么时候用 `transition`


✅ 适合场景


**有「前后两个状态」**，中间过程交给浏览器补。


 **必须有“触发条件”**

- class 切换
- hover
- JS 改样式
- Vue / React 状态变化

### 🧠 本质

> “从 A → B 的过渡”

### 
什么时候用 `animation`


**动画自己会动，不需要外界触发**


👉 **有完整时间轴**

- 0% → 50% → 100%
- 循环
- 自动播放

### 🧠 本质

> “我定义好剧本，你按剧本演”

### 什么时候一定要用 raf


✅ 1️⃣ 动画进度由「连续数值」控制


## 🍉 router里的query和params


| 特性           | `query` (查询参数)                              | `params` (路径参数)                      |
| ------------ | ------------------------------------------- | ------------------------------------ |
| **URL 表现形式** | `/search?keyword=vue&page=1` (使用 `?` 和 `&`) | `/user/123` (直接拼接在路径中)               |
| **用途/语义**    | 可选的、附加的筛选条件                                 | 必需的、标识资源核心身份的 ID                     |
| **路由定义**     | 路径中无需定义占位符，如 `path: '/search'`              | 路径中**必须**定义占位符，如 `path: '/user/:id'` |


本质：


**有没有 params，决定这条路由能不能匹配上**


**有没有 query，不影响路由是否匹配**

