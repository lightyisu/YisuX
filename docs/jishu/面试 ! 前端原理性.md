---
catalog:
  - jishu
date: '2025-11-08 08:00:00'
type: Post
slug: jishusss
title: 面试 | 前端原理性
status: 已发布
urlname: 2a5e9dc9-c245-8040-af90-c77fe0c7c682
updated: '2026-01-27 23:49:00'
---

整理的一些偏原理性的前端问题：


## 在浏览器中输入地址回车后会发生什么


从输入 URL到页面展示的全过程（DNS 查询 -> TCP 握手 -> HTTP 请求 -> 解析 HTML -> 构建 DOM 树 -> 构建 CSSOM 树 -> 构建渲染树 -> 布局 -> 绘制）


## 闭包 (Closure)是什么


闭包：函数在**“定义时”**记住了它外层作用域的变量，并且在**“执行时”**还能访问它


当一个函数能够记住并访问它所在的词法作用域时，就产生了闭包，即使函数是在其当前词法作用域之外执行的。


当你（函数）离开房间（词法作用域）去别的地方执行时，这个背包让你依然能访问到房间里的那些物品（变量）。


```typescript
function makeCounter() {
  let count = 0; // count 位于 makeCounter 的词法作用域内

  // 这个内部函数就是一个闭包
  return function() {
    count++; // 它可以访问并修改外部作用域的 count 变量
    return count;
  };
}
```


调用函数后，返回匿名函数，虽然理论要销毁 count 这个变量，因为匿名函数和原来词法作用域里的变量仍然有联系引用，通过垃圾回收机制不去回收联系的变量，这样变量就被封闭住了。


**优点：**


1.提供私有变量，实现数据封装和隐藏
2.让变量的状态得以持久化



**应用场景：**


防抖节流模块化


缺点：内存泄漏，因为不怎么回收


**使用方法**：


并不是常见的return一个匿名函数就是唯一的写法，只要一个函数访问了它定义时的外层作用域变量，这个函数就是闭包


```javascript
let fn;

function outer() {
  let a = 1;
  fn = function () {
    console.log(a);
  };
}

outer();
fn(); // 1
```


## **执行上下文 (Execution Context) 与调用栈 (Call Stack)**


JavaScript 代码执行的底层机制：**执行上下文** 和 **调用栈**。
**执行上下文：**每当一段代码准备执行时，JS 引擎都会为它创建一个执行上下文。


执行上下文主要有三种：**1.全局执行上下文 2.函数执行上下文 3.Eval函数执行上下文**


创建阶段：


1.**创建词法环境**

- 它记录了当前作用域内的所有**变量、函数声明**以及**对外部环境的引用**（这就是作用域链的基础）。
- 对于 **`let`** 和 **`const`** 声明的变量，它们会被创建但**不会被初始化**，处于“未初始化”状态。这就是为什么在声明前访问它们会报错（暂时性死区，TDZ）。
- 对于 **`function`** 声明，它会被**完整创建并初始化**，这就是为什么函数声明可以在定义之前被调用（函数提升）。

tips:


**`let`** **和** **`const`** **定义的函数（即函数表达式）不会被“完整地”提升，但它们声明的变量会被提升进入“暂时性死区”。**


**不可以在声明之前调用!**


2.**确定** **`this`** **的指向**






## 深拷贝浅拷贝


核心：其实就是能不能完全把对象嵌套的属性也给复制过去的问题。


**浅拷贝（只能拷贝一层 更深的还是引用的地址 不是完全拷贝）：**


1.**`Object.assign()`**


```typescript
let originalObj = {
  name: '张三',
  age: 25,
  hobbies: ['读书', '游泳']
};

// 使用 Object.assign 进行浅拷贝
let shallowCopy = Object.assign({}, originalObj);

// 修改原始类型的值
shallowCopy.name = '李四';
console.log(originalObj.name); // '张三' (不受影响)

// 修改引用类型的值
shallowCopy.hobbies.push('跑步');
console.log(originalObj.hobbies); // ['读书', '游泳', '跑步'] (被影响了！)
```


2.扩展运算符 `...` 


3.**`Array.prototype.slice()`** **或** **`Array.from()`**


**深拷贝（完全拷贝，更深的嵌套属性此刻也不是原引用了独立起来了）：**


1.`JSON.parse(JSON.stringify(obj))` (简单但有缺陷)


2.递归函数 (最根本的解决方案)


3.现代浏览器内置方法 `structuredClone()` (推荐)


其实还得最后看polyfill一下 这个有点太新了貌似


4.使用第三方库 (如 Lodash)


cloneDeep


```typescript
// 需要先安装 lodash: npm install lodash
import { cloneDeep } from 'lodash';

let originalObj = { /* ... */ };
let deepCopy = cloneDeep(originalObj);
```


### **总结与对比**


| **方法**                     | **类型**  | **能否处理嵌套对象** | **优点**           | **缺点**             |
| -------------------------- | ------- | ------------ | ---------------- | ------------------ |
| **`Object.assign()`**      | 浅拷贝     | 否            | 简单               | 嵌套对象会共享引用          |
| 扩展运算符 **`...`**            | 浅拷贝     | 否            | 语法简洁，ES6 标准      | 嵌套对象会共享引用          |
| **`JSON.parse/stringify`** | 深拷贝     | 能            | 简单快捷             | 类型丢失多，无法处理函数、循环引用  |
| **递归函数**                   | **深拷贝** | **能**        | **可自定义，理解原理**    | **实现复杂，需考虑各种边界情况** |
| **`structuredClone()`**    | **深拷贝** | **能**        | **原生API，强大，性能好** | **无法拷贝函数、原型链**     |
| **Lodash** **`cloneDeep`** | **深拷贝** | **能**        | **最健壮，功能最全**     | **增加项目体积**         |


## 简单的双向绑定（响应式原理）


```javascript
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <label>game</label>
    <input type="text" class="gamename" onchange="changeGameName(this)" />
    <button onclick="rename()">rename</button>
    <p>show: <span id="showName"></span></p>
    <script>
      let game = {
        _name: "",
      };
      const input = document.querySelector(".gamename");
      const showName = document.getElementById("showName");
      Object.defineProperty(game, "gamename", {
        get() {
          return this._name;
        },
        set(newVal) {
        /*** CORE AREA *****/
          if (newVal == this._name) return;
          this._name = newVal;
          input.value = newVal;
          showName.textContent = newVal;
        /*** CORE AREA *****/
        },
      });
      function changeGameName(e) {
        game.gamename = e.value;
      }
      function rename() {
        game.gamename = "default";
      }
    </script>
  </body>
</html>
```


响应式本质：**_name绑定input，通过拦截方法把DOM操作挂载到set上实现数据驱动**


核心是数据拦截器的副作用驱动DOM 造成响应式系统


这里有个小小的坑，就是字面`_name`实际上是一个临时属性，把`name`的拦截挂到这里可以**防止递归**，然后获取的时候通过`_name`值获取，`name`只是一个挂号，实际的值在`_name`上。真正的name没写在字面量上。


## IIFE


iife主要解决var作用域的问题


### 经典问题


```javascript
// 使用 var 的问题
var funcs = [];
for (var i = 0; i < 3; i++) {
  funcs[i] = function() {
    console.log(i); // 所有函数都会打印 3
  };
}
funcs[0](); // 3
funcs[1](); // 3
funcs[2](); // 3
```


**没有存** **`i`** **的值，**存的是一个函数，而这个函数**引用了外部的** **`i`**


**自己理解**：一直存的是var i下的变量地址，运行的时候这个变量的值已经是3了自然打印3
!!!**闭包保存的是 变量本身的引用(地址），不是当时的值.
!!!函数执行时才读取** **`i`****，而不是创建时**


解决方法：


通过 IIFE 为每次循环创建一个新的函数作用域，将 **`i`** 的值“锁定”在内部。


```javascript
// 使用 IIFE 解决
var funcs = [];
for (var i = 0; i < 3; i++) {
  (function(index) {
    funcs[index] = function() {
      console.log(index); // 0, 1, 2
    };
  })(i);
}
funcs[0](); // 0
funcs[1](); // 1
funcs[2](); // 2
```


类似问题：


```javascript
for (var i = 0; i < 10; i++) {
  setTimeout(function () {
    console.log(i);
  }, 0);
}
```


闭包：函数在**“定义时”**记住了它外层作用域的变量，并且在**“执行时”**还能访问它


所有闭包引用的是“同一个 i” 闭包 ≠ 值拷贝 闭包 = 变量引用


## Vue设计模式


### 发布订阅模式


**引入一个中间人（调度中心），让发布者和订阅者完全解耦，双方不直接通信。**


调度中心是这个模式的核心，它的内部实现非常简单：

1. **数据结构**：调度中心的核心通常是一个**对象（或字典/Map）**。
    - 这个对象的 **`key`** 是**事件/主题的名称**（例如：**`'news'`**, **`'sports'`**）。
    - 这个对象的 **`value`** 是一个**数组**，存放着所有订阅了这个主题的**回调函数**（订阅者的处理逻
2. **两个核心方法**：
    - **`subscribe(event, callback)`**：订阅方法。
        - 接收一个事件名 **`event`** 和一个回调函数 **`callback`**。
        - 将这个 **`callback`** 添加到 **`events[event]`** 数组中。如果这个 **`event`** 还不存在，就先创建一个空数组。
    - **`publish(event, data)`**：发布方法。
        - 接收一个事件名 **`event`** 和要发送的数据 **`data`**。
        - 在 **`events`** 对象中找到 **`event`** 对应的数组。
        - **遍历**这个数组，并**依次执行**里面所有的回调函数，把 **`data`** 作为参数传进去。

**1. 核心响应式系统**


这是 Vue 最核心的发布订阅模式实现。

- **发布者**: Vue 组件中的 **`data`** 属性。当这些数据发生变化时，它们就“发布”了一个变更通知。
- **订阅者**: 依赖这些数据的 DOM 部分（模板）、计算属性（**`computed`**）和侦听器（**`watcher`**）。它们在组件渲染时会“订阅”自己所依赖的数据。
- **调度中心**: Vue 内部的依赖收集和通知系统。

伪代码：


```javascript
#b站订阅例子
事件中心：B站服务器
// B站消息中心
const Bilibili = {
    channels: {
       '今天没准备儿':[(fan1),(fan2),(fan3)]
    },   // 记录：UP 主 -> 粉丝回调列表
         // record:data -> DOM依赖

    subscribe(up, fanCallback) {
        if (!this.channels[up]) {
            this.channels[up] = [];
        }
        //将依赖dom推送到所依赖的data节点里
        this.channels[up].push(fanCallback);
    },

    publish(up, newVideo) {
        const fans = this.channels[up];
        if (!fans) return;

        // 给所有粉丝推送消息
        // 给所有依赖dom发消息 让他们响应式改变
        fans.forEach(callback => callback(newVideo));
    }
};
// 小明关注了 某UP主
// 某dom节点订阅了 某data数据
Bilibili.subscribe("LexBurner", (video) => {
    console.log("小明收到推送:", video.title);
});

// 小红也关注了
Bilibili.subscribe("LexBurner", (video) => {
    console.log("小红收到推送:", video.title);
});
// UP主发布新视频
Bilibili.publish("LexBurner", {
    title: "《我又发新视频啦！》",
    url: "/video/BV123456"
});
//小明收到推送: 《我又发新视频啦！》
//小红收到推送: 《我又发新视频啦！》
```


**工作流程**:

1. 当组件渲染时，Vue 会记录下模板中用到了哪些 **`data`** 属性（这个过程叫**依赖收集**）。
2. 当某个 **`data`** 属性被修改时，Vue 会通知所有订阅了该属性的“订阅者”。
3. 订阅者收到通知后，会自动更新 DOM 或重新计算计算属性的值。

**2. 组件间通信 - 自定义事件**


这是非常直观的发布订阅模式，常用于父子组件通信。

- **发布者**: 子组件通过 **`this.$emit('my-event', data)`** 发布一个名为 **`my-event`** 的事件。
- **订阅者**: 父组件在模板中使用 **`<child-component @my-event="parentMethod" />`** 来订阅这个事件。
- **调度中心**: Vue 的组件实例本身，它内置了 **`$on`**, **`$emit`**, **`$off`** 等方法来管理事件。

**3. 全局事件总线**


在 Vue 2 中，这是一种常见的跨组件通信方式，它和你写的 **`PubSub`** 类几乎一模一样。

- **实现**: 通常创建一个独立的 Vue 实例作为事件总线。
- **发布**: 在任何组件中，**`EventBus.$emit('event-name', data)`**。
- **订阅**: 在任何组件中，**`EventBus.$on('event-name', callback)`**。

**注意**: 在 Vue 3 中，移除了 **`$on`**, **`$off`** 等实例方法，官方推荐使用像 [**Mitt**](https://github.com/developit/mitt) 这样的第三方库来实现事件总线，或者使用状态管理库。


**4. 状态管理库**


无论是 Vuex (Vue 2/3) 还是 Pinia (Vue 3 推荐)，它们的核心都是一个巨大的、集中式的发布订阅系统。

- **发布者**: 组件通过 **`dispatch`** 一个 **`action`** 或 **`commit`** 一个 **`mutation`** 来发布一个“状态变更”的意图。
- **订阅者**: 所有在模板或计算属性中使用了该 **`state`** 的组件。
- **调度中心**: Vuex 或 Pinia 的 Store。它接收变更请求，更新 **`state`**，然后通知所有订阅者更新。

### **观察者模式**


这与发布订阅模式非常相似，但有一个关键区别：在观察者模式中，**发布者（被观察者）会直接维护一个订阅者（观察者）列表**。而在发布订阅模式中，发布者和订阅者之间有一个独立的“调度中心”。

- **应用**: Vue 的响应式系统在底层更接近观察者模式。每个响应式对象都有一个 **`Dep`** 类（Dependency）的实例，它存储了所有订阅它的 **`Watcher`** 实例。当数据变化时，**`Dep`** 会直接通知它内部的 **`Watcher`** 列表。

### **单例模式**


确保一个类只有一个实例，并提供一个全局访问点。


js实现思想：

- **检查**：判断那个静态变量是否已经有值。
- **创建**：如果为空（即实例还未被创建），就调用 **`new`** 来创建一个新的实例，并存入静态变量中。
- **返回**：如果已经有值，直接返回这个已经存在的实例。
- **应用**:
    - **应用实例**: **`new Vue()`** (Vue 2) 或 **`createApp()`** (Vue 3) 创建的应用实例通常是单例。
    - **Vuex/Pinia Store**: 整个应用通常只有一个全局的 Store 实例。
    - **Vue Router**: 路由器实例也是单例的。

### **工厂模式**


**将创建对象的过程封装起来，客户端不直接通过** **`new`** **来创建对象，而是通过一个“工厂”来获取所需的对象。**


```javascript
//传统模式
// 1. 定义产品类
class Car {
  drive() {
    console.log('驾驶小汽车...');
  }
}

class Bike {
  drive() {
    console.log('骑自行车...');
  }
}

// 2. 客户端代码 - 直接创建
function createVehicleAndDrive(type) {
  let myVehicle;

  // 客户端需要知道所有具体的类名，并负责创建逻辑
  if (type === 'car') {
    myVehicle = new Car();
  } else if (type === 'bike') {
    myVehicle = new Bike();
  }

  myVehicle.drive();
}

createVehicleAndDrive('car'); // 输出: 驾驶小汽车...

// 工厂模式 （把之前的逻辑提前封装）
class VehicleFactory {
  createProduct(type) {
    if (type === 'car') {
      return new Car(); // 创建小汽车
    } else if (type === 'bike') {
      return new Bike(); // 创建自行车
    }
    return null;
  }
}
```

- **应用**: Vue 的 **`createElement`** 方法（或 **`h`** 函数）就是一个典型的工厂。它负责创建虚拟 DOM 节点 (VNode)。你不需要关心 **`VNode`** 是如何被具体创建的，只需要调用这个工厂函数并传入参数即可。

### **代理模式**


为一个对象提供一个代用品或占位符，以控制对这个对象的访问。

- **应用**: 这是 **Vue 3 响应式系统的核心**。当你使用 **`reactive()`** 或 **`ref()`** 创建一个响应式对象时，Vue 会返回一个原始对象的**代理**。你对这个代理的任何操作（如读取、修改属性）都会被 JavaScript 的 **`Proxy`** API 拦截，从而使 Vue 能够在这些操作发生时执行依赖收集和触发更新等逻辑。

### **组合模式**


将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

- **应用**: Vue 的**组件系统**本身就是组合模式的完美体现。一个组件可以包含多个子组件，形成一个组件树。你可以像处理单个组件一样处理整个组件树（例如，渲染一个父组件，就会递归地渲染它所有的子组件）。

## 前端路由模式


对于前端路由来说，路由的映射函数通常是进行一些 `DOM` 的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。前端路由主要有以下两种实现方案：

- `Hash`
- `History`

**Hash 模式**


早期的前端路由的实现就是基于 `location.hash` 来实现的。


hash原理：直接使用 `JavaScript`来对 `loaction.hash` 进行赋值，从而改变 `URL`，触发 `hashchange` 事件
**History 模式**
提供了 `History API` 来实现 `URL` 的变化。其中做最主要的 `API` 有以下两个：`history.pushState()` 和 `history.repalceState()`


在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录


## JS 操作 DOM 是同步， **DOM 更新（浏览器）是异步**


**JS 操作 DOM 本身是同步执行的**，**但浏览器的 DOM 渲染是异步批量进行的**，**只有在读取布局信息或下一帧时才会触发渲染**


### **为什么** **`nextTick`** **才能获取到修改后的值？（因为 JS 是单线程的）**


这是理解这个问题的关键。请看下面这段 Vue 伪代码：


```javascript
this.msg = 'Hello'; // 1. 修改数据
console.log(this.$refs.div.innerText); // 2. 立即读取 DOM
```


**核心：框架是数据驱动DOM但是不会立刻操作 DOM**


解释：


**因为 JavaScript 是单线程的，它是“一口气”执行完代码的。**

1. **执行** **`this.msg = 'Hello'`**：
Vue 并不是立马去改 DOM。Vue 内部有一个 **`Watcher`**，它发现数据变了，只是默默地把自己标记为“dirty”（脏了），并把更新任务推送到一个异步队列中。
_此时，DOM 还没变，只是“计划要变了”。_
2. **执行** **`console.log(...)`**：
JS 引擎继续往下跑，同步代码还没执行完，根本没空去处理那个“异步队列”。所以此时你去读 DOM，读到的自然是**上一次渲染留下的旧值**。
3. **同步代码执行完毕**：
JS 主线程空出来了。事件循环开始处理微任务或宏任务。这时，Vue 的更新调度器才开始工作，执行更新操作，把 DOM 变成 "Hello"。

**`nextTick`** **的作用：****`nextTick`** 就是把你的回调函数，塞到“DOM 更新完成”之后的那一步。


```javascript
this.msg = 'Hello';
// 把这个回调放到任务队列里，等本次 JS 执行完、DOM 更新完后，再执行它
this.$nextTick(() => {
    console.log(this.$refs.div.innerText); // 这时候才是 "Hello"
});
```


**自己总结：**


原生改的是 DOM 本体，所以马上变；框架改的是数据，等下一轮才同步到 DOM，所以要 nextTick。


**和时间循环的关系：**


Vue 开启了一个 **`Promise`**（或者 **`MutationObserver`**），把“更新 DOM”这个回调函数，塞进了 **微任务队列**。


原生改 DOM 是同步，框架改状态是异步（进入 microtask），DOM 更新要等同步代码结束 + microtask 执行，再进入渲染，所以要用 nextTick。


**为什么框架要这么实现：**


1. 性能：避免频繁重排（Reflow）与重绘（Repaint）


2. 批处理（Batching）：减少重复渲染


3. Fiber / scheduler / 优先级调度需要异步模型


4. 确保状态一致性


5. 避免“中间状态”渲染


6. 与跨平台渲染模型兼容


7. 允许框架做更多优化


**框架要自己做一点优化的副作用**

