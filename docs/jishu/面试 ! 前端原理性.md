---
catalog:
  - jishu
date: '2025-11-08 08:00:00'
type: Post
slug: jishusss
title: 面试 | 前端原理性
status: 已发布
urlname: 2a5e9dc9-c245-8040-af90-c77fe0c7c682
updated: '2026-01-11 15:02:00'
---

整理的一些偏原理性的前端问题：


## 在浏览器中输入地址回车后会发生什么


从输入 URL到页面展示的全过程（DNS 查询 -> TCP 握手 -> HTTP 请求 -> 解析 HTML -> 构建 DOM 树 -> 构建 CSSOM 树 -> 构建渲染树 -> 布局 -> 绘制）


## **`[] == ![]`** **为什么是** **`true`****？**


解析（这是隐式转换规则（特别是 == 和 +）与 显式转换方法的问题）：

1. **`![]`**：首先计算 **`!`** 运算符。**`[]`** 是一个对象，在布尔上下文中是 **`true`**。所以 **`![]`** 就是 **`false`**。
2. 表达式变为：**`[] == false`**。
3. 根据规则 **`boolean == 任何类型`**，将 **`boolean`** 转换为 **`number`**。**`false`** 转换为 **`0`**。
4. 表达式变为：**`[] == 0`**。
5. 根据规则 **`对象 == number`**，将对象 **`[]`** 通过 **`ToPrimitive`** 转换为原始值。提示是 **`number`**。
    - 调用 **`[].valueOf()`**，返回 **`[]`** 本身（不是原始值）。
    - 继续调用 **`[].toString()`**，返回 **`''`**（空字符串）。
6. 表达式变为：**`'' == 0`**。
7. 根据规则 **`string == number`**，将 **`string`** 转换为 **`number`**。**`''`** 转换为 **`0`**。
8. 表达式变为：**`0 == 0`**。
9. 结果：**`true`**。

## 闭包 (Closure)是什么


当一个函数能够记住并访问它所在的词法作用域时，就产生了闭包，即使函数是在其当前词法作用域之外执行的。


当你（函数）离开房间（词法作用域）去别的地方执行时，这个背包让你依然能访问到房间里的那些物品（变量）。


```typescript
function makeCounter() {
  let count = 0; // count 位于 makeCounter 的词法作用域内

  // 这个内部函数就是一个闭包
  return function() {
    count++; // 它可以访问并修改外部作用域的 count 变量
    return count;
  };
}
```


调用函数后，返回匿名函数，虽然理论要销毁 count 这个变量，因为匿名函数和原来词法作用域里的变量仍然有联系引用，通过垃圾回收机制不去回收联系的变量，这样变量就被封闭住了。


**优点：**


1.提供私有变量，实现数据封装和隐藏
2.让变量的状态得以持久化



**应用场景：**


防抖节流模块化


缺点：内存泄漏，因为不怎么回收


## **执行上下文 (Execution Context) 与调用栈 (Call Stack)**


JavaScript 代码执行的底层机制：**执行上下文** 和 **调用栈**。
**执行上下文：**每当一段代码准备执行时，JS 引擎都会为它创建一个执行上下文。


执行上下文主要有三种：**1.全局执行上下文 2.函数执行上下文 3.Eval函数执行上下文**


创建阶段：


1.**创建词法环境**

- 它记录了当前作用域内的所有**变量、函数声明**以及**对外部环境的引用**（这就是作用域链的基础）。
- 对于 **`let`** 和 **`const`** 声明的变量，它们会被创建但**不会被初始化**，处于“未初始化”状态。这就是为什么在声明前访问它们会报错（暂时性死区，TDZ）。
- 对于 **`function`** 声明，它会被**完整创建并初始化**，这就是为什么函数声明可以在定义之前被调用（函数提升）。

tips:


**`let`** **和** **`const`** **定义的函数（即函数表达式）不会被“完整地”提升，但它们声明的变量会被提升进入“暂时性死区”。**


**不可以在声明之前调用!**


2.**确定** **`this`** **的指向**



执行阶段
在准备工作完成后，代码开始一行一行地执行。


## 深拷贝浅拷贝


核心：其实就是能不能完全把对象嵌套的属性也给复制过去的问题。


**浅拷贝（只能拷贝一层 更深的还是引用的地址 不是完全拷贝）：**


1.**`Object.assign()`**


```typescript
let originalObj = {
  name: '张三',
  age: 25,
  hobbies: ['读书', '游泳']
};

// 使用 Object.assign 进行浅拷贝
let shallowCopy = Object.assign({}, originalObj);

// 修改原始类型的值
shallowCopy.name = '李四';
console.log(originalObj.name); // '张三' (不受影响)

// 修改引用类型的值
shallowCopy.hobbies.push('跑步');
console.log(originalObj.hobbies); // ['读书', '游泳', '跑步'] (被影响了！)
```


2.扩展运算符 `...` 


3.**`Array.prototype.slice()`** **或** **`Array.from()`**


**深拷贝（完全拷贝，更深的嵌套属性此刻也不是原引用了独立起来了）：**


1.`JSON.parse(JSON.stringify(obj))` (简单但有缺陷)


2.递归函数 (最根本的解决方案)


3.现代浏览器内置方法 `structuredClone()` (推荐)


其实还得最后看polyfill一下 这个有点太新了貌似


4.使用第三方库 (如 Lodash)


cloneDeep


```typescript
// 需要先安装 lodash: npm install lodash
import { cloneDeep } from 'lodash';

let originalObj = { /* ... */ };
let deepCopy = cloneDeep(originalObj);
```


### **总结与对比**


| **方法**                     | **类型**  | **能否处理嵌套对象** | **优点**           | **缺点**             |
| -------------------------- | ------- | ------------ | ---------------- | ------------------ |
| **`Object.assign()`**      | 浅拷贝     | 否            | 简单               | 嵌套对象会共享引用          |
| 扩展运算符 **`...`**            | 浅拷贝     | 否            | 语法简洁，ES6 标准      | 嵌套对象会共享引用          |
| **`JSON.parse/stringify`** | 深拷贝     | 能            | 简单快捷             | 类型丢失多，无法处理函数、循环引用  |
| **递归函数**                   | **深拷贝** | **能**        | **可自定义，理解原理**    | **实现复杂，需考虑各种边界情况** |
| **`structuredClone()`**    | **深拷贝** | **能**        | **原生API，强大，性能好** | **无法拷贝函数、原型链**     |
| **Lodash** **`cloneDeep`** | **深拷贝** | **能**        | **最健壮，功能最全**     | **增加项目体积**         |


## 简单的双向绑定（响应式原理）


```javascript
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <label>姓名:</label
    ><input type="text" class="name" onchange="changeName(this)" />
    <button onclick="changeInput()">恢复姓名为rose</button>
    <script>
      let person = {
        _name: "",
      };
      const input = document.querySelector(".name");
      Object.defineProperty(person, "name", {
        enumerable: true,
        configurable: true,
        //默认给false 需要手动设定true
        get() {
          return this._name;
        },
        set(newval) {
          console.log("setting");
          if (newval == this._name) {
            return;
          }
          this._name = newval;
          input.value = newval;
        },
      });
      function changeName(el) {
        person.name = el.value;
      }
    </script>
  </body>
</html>
```


这里有个小小的坑，就是字面`_name`实际上是一个临时属性，把`name`的拦截挂到这里可以**防止递归**，然后获取的时候通过`_name`值获取，`name`只是一个挂号，实际的值在`_name`上。真正的name没写在字面量上。


## 有let了吗 iife还有用


iife主要解决var作用域的问题


### 经典问题


```javascript
// 使用 var 的问题
var funcs = [];
for (var i = 0; i < 3; i++) {
  funcs[i] = function() {
    console.log(i); // 所有函数都会打印 3
  };
}
funcs[0](); // 3
funcs[1](); // 3
funcs[2](); // 3
```


解决方法：


通过 IIFE 为每次循环创建一个新的函数作用域，将 **`i`** 的值“锁定”在内部。


```javascript
// 使用 IIFE 解决
var funcs = [];
for (var i = 0; i < 3; i++) {
  (function(index) {
    funcs[index] = function() {
      console.log(index); // 0, 1, 2
    };
  })(i);
}
funcs[0](); // 0
funcs[1](); // 1
funcs[2](); // 2
```


| 特性/场景                | `let` / `const` | IIFE            |
| -------------------- | --------------- | --------------- |
| **主要目的**             | 声明块级作用域变量       | 创建独立的函数作用域并立即执行 |
| **解决循环问题**           | ✅ **首选，代码简洁**   | ✅ (旧方法)         |
| **创建私有变量/模块**        | ❌ (无法单独实现)      | ✅ **核心用途**      |
| **避免全局污染**           | ✅ (在模块化文件中)     | ✅ **非常强大**      |
| **立即执行初始化代码**        | ❌ (需要额外调用)      | ✅ **天生如此**      |
| **传递参数（如window, $）** | ❌ (无法直接实现)      | ✅ **非常方便**      |


##  Vue设计模式


### 发布订阅模式


**引入一个中间人（调度中心），让发布者和订阅者完全解耦，双方不直接通信。**


调度中心是这个模式的核心，它的内部实现非常简单：

1. **数据结构**：调度中心的核心通常是一个**对象（或字典/Map）**。
    - 这个对象的 **`key`** 是**事件/主题的名称**（例如：**`'news'`**, **`'sports'`**）。
    - 这个对象的 **`value`** 是一个**数组**，存放着所有订阅了这个主题的**回调函数**（订阅者的处理逻
2. **两个核心方法**：
    - **`subscribe(event, callback)`**：订阅方法。
        - 接收一个事件名 **`event`** 和一个回调函数 **`callback`**。
        - 将这个 **`callback`** 添加到 **`events[event]`** 数组中。如果这个 **`event`** 还不存在，就先创建一个空数组。
    - **`publish(event, data)`**：发布方法。
        - 接收一个事件名 **`event`** 和要发送的数据 **`data`**。
        - 在 **`events`** 对象中找到 **`event`** 对应的数组。
        - **遍历**这个数组，并**依次执行**里面所有的回调函数，把 **`data`** 作为参数传进去。

**1. 核心响应式系统**


这是 Vue 最核心的发布订阅模式实现。

- **发布者**: Vue 组件中的 **`data`** 属性。当这些数据发生变化时，它们就“发布”了一个变更通知。
- **订阅者**: 依赖这些数据的 DOM 部分（模板）、计算属性（**`computed`**）和侦听器（**`watcher`**）。它们在组件渲染时会“订阅”自己所依赖的数据。
- **调度中心**: Vue 内部的依赖收集和通知系统。

伪代码：


```javascript
#b站订阅例子
事件中心：B站服务器
// B站消息中心
const Bilibili = {
    channels: {
       '今天没准备儿':[(fan1),(fan2),(fan3)]
    },   // 记录：UP 主 -> 粉丝回调列表
         // record:data -> DOM依赖

    subscribe(up, fanCallback) {
        if (!this.channels[up]) {
            this.channels[up] = [];
        }
        //将依赖dom推送到所依赖的data节点里
        this.channels[up].push(fanCallback);
    },

    publish(up, newVideo) {
        const fans = this.channels[up];
        if (!fans) return;

        // 给所有粉丝推送消息
        // 给所有依赖dom发消息 让他们响应式改变
        fans.forEach(callback => callback(newVideo));
    }
};
// 小明关注了 某UP主
// 某dom节点订阅了 某data数据
Bilibili.subscribe("LexBurner", (video) => {
    console.log("小明收到推送:", video.title);
});

// 小红也关注了
Bilibili.subscribe("LexBurner", (video) => {
    console.log("小红收到推送:", video.title);
});
// UP主发布新视频
Bilibili.publish("LexBurner", {
    title: "《我又发新视频啦！》",
    url: "/video/BV123456"
});
//小明收到推送: 《我又发新视频啦！》
//小红收到推送: 《我又发新视频啦！》
```


**工作流程**:

1. 当组件渲染时，Vue 会记录下模板中用到了哪些 **`data`** 属性（这个过程叫**依赖收集**）。
2. 当某个 **`data`** 属性被修改时，Vue 会通知所有订阅了该属性的“订阅者”。
3. 订阅者收到通知后，会自动更新 DOM 或重新计算计算属性的值。

**2. 组件间通信 - 自定义事件**


这是非常直观的发布订阅模式，常用于父子组件通信。

- **发布者**: 子组件通过 **`this.$emit('my-event', data)`** 发布一个名为 **`my-event`** 的事件。
- **订阅者**: 父组件在模板中使用 **`<child-component @my-event="parentMethod" />`** 来订阅这个事件。
- **调度中心**: Vue 的组件实例本身，它内置了 **`$on`**, **`$emit`**, **`$off`** 等方法来管理事件。

**3. 全局事件总线**


在 Vue 2 中，这是一种常见的跨组件通信方式，它和你写的 **`PubSub`** 类几乎一模一样。

- **实现**: 通常创建一个独立的 Vue 实例作为事件总线。
- **发布**: 在任何组件中，**`EventBus.$emit('event-name', data)`**。
- **订阅**: 在任何组件中，**`EventBus.$on('event-name', callback)`**。

**注意**: 在 Vue 3 中，移除了 **`$on`**, **`$off`** 等实例方法，官方推荐使用像 [**Mitt**](https://github.com/developit/mitt) 这样的第三方库来实现事件总线，或者使用状态管理库。


**4. 状态管理库**


无论是 Vuex (Vue 2/3) 还是 Pinia (Vue 3 推荐)，它们的核心都是一个巨大的、集中式的发布订阅系统。

- **发布者**: 组件通过 **`dispatch`** 一个 **`action`** 或 **`commit`** 一个 **`mutation`** 来发布一个“状态变更”的意图。
- **订阅者**: 所有在模板或计算属性中使用了该 **`state`** 的组件。
- **调度中心**: Vuex 或 Pinia 的 Store。它接收变更请求，更新 **`state`**，然后通知所有订阅者更新。

### **观察者模式**


这与发布订阅模式非常相似，但有一个关键区别：在观察者模式中，**发布者（被观察者）会直接维护一个订阅者（观察者）列表**。而在发布订阅模式中，发布者和订阅者之间有一个独立的“调度中心”。

- **应用**: Vue 的响应式系统在底层更接近观察者模式。每个响应式对象都有一个 **`Dep`** 类（Dependency）的实例，它存储了所有订阅它的 **`Watcher`** 实例。当数据变化时，**`Dep`** 会直接通知它内部的 **`Watcher`** 列表。

### **单例模式**


确保一个类只有一个实例，并提供一个全局访问点。


js实现思想：

- **检查**：判断那个静态变量是否已经有值。
- **创建**：如果为空（即实例还未被创建），就调用 **`new`** 来创建一个新的实例，并存入静态变量中。
- **返回**：如果已经有值，直接返回这个已经存在的实例。
- **应用**:
    - **应用实例**: **`new Vue()`** (Vue 2) 或 **`createApp()`** (Vue 3) 创建的应用实例通常是单例。
    - **Vuex/Pinia Store**: 整个应用通常只有一个全局的 Store 实例。
    - **Vue Router**: 路由器实例也是单例的。

### **工厂模式**


**将创建对象的过程封装起来，客户端不直接通过** **`new`** **来创建对象，而是通过一个“工厂”来获取所需的对象。**


```javascript
//传统模式
// 1. 定义产品类
class Car {
  drive() {
    console.log('驾驶小汽车...');
  }
}

class Bike {
  drive() {
    console.log('骑自行车...');
  }
}

// 2. 客户端代码 - 直接创建
function createVehicleAndDrive(type) {
  let myVehicle;

  // 客户端需要知道所有具体的类名，并负责创建逻辑
  if (type === 'car') {
    myVehicle = new Car();
  } else if (type === 'bike') {
    myVehicle = new Bike();
  }

  myVehicle.drive();
}

createVehicleAndDrive('car'); // 输出: 驾驶小汽车...

// 工厂模式 （把之前的逻辑提前封装）
class VehicleFactory {
  createProduct(type) {
    if (type === 'car') {
      return new Car(); // 创建小汽车
    } else if (type === 'bike') {
      return new Bike(); // 创建自行车
    }
    return null;
  }
}
```

- **应用**: Vue 的 **`createElement`** 方法（或 **`h`** 函数）就是一个典型的工厂。它负责创建虚拟 DOM 节点 (VNode)。你不需要关心 **`VNode`** 是如何被具体创建的，只需要调用这个工厂函数并传入参数即可。

### **代理模式**


为一个对象提供一个代用品或占位符，以控制对这个对象的访问。

- **应用**: 这是 **Vue 3 响应式系统的核心**。当你使用 **`reactive()`** 或 **`ref()`** 创建一个响应式对象时，Vue 会返回一个原始对象的**代理**。你对这个代理的任何操作（如读取、修改属性）都会被 JavaScript 的 **`Proxy`** API 拦截，从而使 Vue 能够在这些操作发生时执行依赖收集和触发更新等逻辑。

### **组合模式**


将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

- **应用**: Vue 的**组件系统**本身就是组合模式的完美体现。一个组件可以包含多个子组件，形成一个组件树。你可以像处理单个组件一样处理整个组件树（例如，渲染一个父组件，就会递归地渲染它所有的子组件）。

## 前端路由模式


对于前端路由来说，路由的映射函数通常是进行一些 `DOM` 的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。前端路由主要有以下两种实现方案：

- `Hash`
- `History`

**Hash 模式**


早期的前端路由的实现就是基于 `location.hash` 来实现的。


hash原理：直接使用 `JavaScript`来对 `loaction.hash` 进行赋值，从而改变 `URL`，触发 `hashchange` 事件
**History 模式**
提供了 `History API` 来实现 `URL` 的变化。其中做最主要的 `API` 有以下两个：`history.pushState()` 和 `history.repalceState()`


在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录

